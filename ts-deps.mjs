#!/usr/bin/env node

// NOTE: this file has been generated by Sonnet-3.5. It hasn't been thoroughly
// tested. I'm keeping the generator prompt below for future updates.

//./agda-deps.mjs//

//PROBLEM:

//The file above implements an script that returns a list of an Agda file
//dependencies, as module names. For example, if an Agda file includes:

//open import Data.Something
//import Foo.Bar.tic
//import Foo.Bar.tac
//...

//The script above will output:

//Data/Something.agda
//Foo/Bar/tic.agda
//Foo/Bar/tac.agda

//We'd like to implement an equivalent ts-deps.mjs script now.

//There is one issue, though:

//Unlike Agda, TypeScript imports are relative. For example, in the 'Foo/Bar/tic.ts' file, we might have:

//import { Something } from '../../Data/Something';
//import { tac } from './tac';

//While, on Agda, we'd have just:

//open import Data.Something
//open import Foo.Bar.tac

//Ideally, the 'ts-deps' command should return an output in the same format as the
//Agda one, i.e., a list of files that this file import, with a path relative to
//the user's cwd. For example, 'ts-deps Foo/Bar/tic.ts' should return:

//Data/Something.ts
//Foo/Bar/tac.ts

//Your goal is to create a COMPLETE ts-deps.mjs file, with that behavior.
//Do it now:

// This script analyzes TypeScript files to extract and list their dependencies.
// It takes a single TypeScript file as input and outputs a list of all its dependencies.
// The output paths are relative to the user's current working directory.

// Functionality:
// 1. Parses the input TypeScript file and extracts import statements.
// 2. Recursively processes imported modules to build a complete dependency tree.
// 3. Handles various TypeScript import syntaxes.
// 4. Resolves file paths for imported modules, considering relative paths.
// 5. Outputs a list of unique dependencies (excluding the input file itself).

// Circular Dependencies:
// - The script checks for circular dependencies by maintaining a 'visited' set.
// - It prevents infinite recursion by not revisiting already processed files.

// Indirect Imports:
// - The script handles indirect imports.
// - If module A imports B, and B imports C, the script will include C in A's dependencies.
// - Achieved through recursive processing of each imported module.

// Supported TypeScript Import Syntax:
// 1. Default imports:
//    - import Foo from './Foo';
// 2. Named imports:
//    - import { Foo, Bar } from '../utils/FooBar';
// 3. Namespace imports:
//    - import * as Utils from '../../utils';
// 4. Side-effect imports:
//    - import '../../styles.css';
// 5. Dynamic imports are not handled.

// Limitations:
// - The script may not handle all possible TypeScript import syntaxes or edge cases.
// - It does not differentiate between default and named exports.
// - It does not resolve modules from node_modules or handle path aliases.
// - It assumes all imports are relative and points to '.ts' files.

import fs from 'fs';
import path from 'path';

function extractDependencies(filePath, visited = new Set(), allDependencies = new Set()) {
  const absolutePath = path.resolve(filePath);

  if (visited.has(absolutePath)) {
    return allDependencies;
  }
  visited.add(absolutePath);

  try {
    const content = fs.readFileSync(absolutePath, 'utf8');
    const importPaths = parseImports(content);
    for (const importPath of importPaths) {
      const resolvedPath = resolveImportPath(absolutePath, importPath);
      if (resolvedPath) {
        const relativePath = path.relative(process.cwd(), resolvedPath);
        allDependencies.add(relativePath);
        extractDependencies(resolvedPath, visited, allDependencies);
      } else {
        // If the import path cannot be resolved, include it as is
        allDependencies.add(importPath);
      }
    }
    return allDependencies;
  } catch (error) {
    console.error(`Error processing file "${absolutePath}": ${error.message}`);
    return allDependencies;
  }
}

function parseImports(content) {
  const importRegex = /^import\s.+?from\s+['"](.+?)['"];?$/gm;
  const sideEffectImportRegex = /^import\s+['"](.+?)['"];?$/gm;
  const imports = [];
  let match;

  while ((match = importRegex.exec(content)) !== null) {
    imports.push(match[1]);
  }

  while ((match = sideEffectImportRegex.exec(content)) !== null) {
    imports.push(match[1]);
  }

  return imports;
}

function resolveImportPath(currentFile, importPath) {
  if (!importPath.startsWith('.')) {
    // Non-relative imports are not handled
    return null;
  }

  const currentDir = path.dirname(currentFile);
  const potentialExtensions = ['.ts', '.tsx', '.js', '.jsx'];
  const potentialPaths = [];

  // Resolve the import path relative to the current file
  let basePath = path.resolve(currentDir, importPath);

  // If importPath points directly to a file
  for (const ext of potentialExtensions) {
    potentialPaths.push(`${basePath}${ext}`);
  }

  // If importPath points to a directory with an index file
  for (const ext of potentialExtensions) {
    potentialPaths.push(path.join(basePath, `index${ext}`));
  }

  for (const p of potentialPaths) {
    if (fs.existsSync(p) && fs.statSync(p).isFile()) {
      return p;
    }
  }

  return null;
}

function fixFilePath(filepath) {
  if (!filepath) {
    console.error(`Usage: ts-deps <file.ts>`);
    process.exit(1);
  }
  let extension = path.extname(filepath);
  if (extension) {
    if (!['.ts', '.tsx'].includes(extension)) {
      console.error("File should be a TypeScript file with .ts or .tsx extension.");
      process.exit(1);
    } else {
      return filepath;
    }
  } else {
    // Try adding .ts extension
    const tsPath = `${filepath}.ts`;
    if (fs.existsSync(tsPath)) {
      return tsPath;
    } else {
      console.error("File extension is missing and .ts file does not exist.");
      process.exit(1);
    }
  }
}

function main() {
  const args = process.argv.slice(2);
  if (args.length !== 1) {
    console.error('Usage: ts-deps <file.ts>');
    process.exit(1);
  }

  const filePath = args[0];
  const fixedFilePath = fixFilePath(filePath);
  const dependencies = extractDependencies(fixedFilePath);

  if (dependencies.size > 0) {
    for (const dep of dependencies) {
      if (path.resolve(dep) !== path.resolve(fixedFilePath)) {
        console.log(dep);
      }
    }
  } else {
    // print nothing so the caller script handles it correctly
  }
}

main();
