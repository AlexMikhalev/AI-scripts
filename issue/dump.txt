// index.ts

// Export Term types
export { Term, Name, LamB } from "./Term/Type";

// Export parser functions
export { parse, parseTerm, readTerm } from "./Term/parse";

// Export term show functions
export { show, showTerm } from "./Term/show";

// Export term HVM conversion
export { toHVM, termToHVM } from "./Term/toHVM";

// Export term transformation functions
export { etaReduce } from "./Term/etaReduce";
export { freeVars } from "./Term/freeVars";
export { linearize } from "./Term/linearize";

// Export prettier
export { prettyTerm, findMet, extractFunctionInfo } from "./Term/pretty";

// Main.ts

import { Term } from "./Term/Type";
import { readTerm } from "./Term/parse";
import { showTerm } from "./Term/show";
import { termToHVM } from "./Term/toHVM";
import { extractFunctionInfo, prettyTerm, findMet } from "./Term/pretty";
import * as net from 'net';
import * as fs from 'fs';
import * as path from 'path';

// Function to send the request, expecting a string
function sendRequest(input: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const client = net.createConnection({ port: 8080, host: 'localhost' }, () => {
      client.write(`${input}\n`);
    });

    let response = '';
    client.on('data', (data) => {
      response += data.toString();
      client.end();
    });

    client.on('end', () => {
      resolve(response.trim());
    });

    client.on('error', (err) => {
      reject(err);
    });
  });
}

// Function to process a Kolmo file
async function processKolmoFile(filePath: string, command: string): Promise<void> {
  try {
    // Read the file
    const code = fs.readFileSync(filePath, 'utf8');
    
    // Parse the term
    const term: Term = readTerm(code);
    // return;
    // Convert to HVM
    const hvm: string = termToHVM(term);
    
    // Format for sending
    const hvmSingleLine = hvm
      .split('\n')
      .map(line => line.replace(/\/\/.*$/, '')) // remove everything after '//'
      .join(' ')                                // join lines with space
      .replace(/\s+/g, ' ')                     // normalize multiple spaces
      .trim();                                  // remove leading/trailing spaces
    
    // Wrap with the appropriate command constructor
    const wrappedHvm = `#${command}{${hvmSingleLine}}`;
    
    // console.log(hvmSingleLine);
    // Send to HVM server
    const result: string = await sendRequest(wrappedHvm);
    const stats: string = findStats(result);

    if(result == "" || result.startsWith("WORK") || !result.startsWith("∅")) {
      console.log("Did not find.");
      return;
    }
    // console.log(result);

    let resTerm = readTerm(result);
    // console.log(JSON.stringify(resTerm));
    let functionInfo = extractFunctionInfo(term, resTerm);
    let met = findMet(term);
    let formatted = prettyTerm(resTerm, met.T, functionInfo);
    console.log(formatted);

    if(stats != "") {
      console.log("\n");
      console.log(stats);
    }

    //
  } catch (err) {
    console.error('Error:', err);
    process.exit(1);
  }
}

// Main CLI function
function main(): void {
  const args = process.argv.slice(2);
  
  if (args.length < 2) {
    console.error('Usage: kolmo <command> <file.kolmo>');
    console.error('Commands:');
    console.error('  gen - Synthesizes a program via NeoGen');
    console.error('  chk - Type check the file');
    console.error('  run - Run the file');
    process.exit(1);
  }
  
  const command = args[0];
  const filePath = args[1];
  
  if (!['gen', 'chk', 'run'].includes(command)) {
    console.error('Error: Command must be one of: gen, chk, run');
    process.exit(1);
  }
  
  if (!fs.existsSync(filePath)) {
    console.error(`Error: File '${filePath}' does not exist.`);
    process.exit(1);
  }
  
  if (!filePath.endsWith('.kolmo')) {
    console.error('Error: File must have .kolmo extension.');
    process.exit(1);
  }
  
  // Convert command to capitalized form for the constructor
  const commandCap = command.charAt(0).toUpperCase() + command.slice(1);
  
  processKolmoFile(filePath, commandCap);
}

function findStats(input: string): string {
    const statsLines = input.split('\n').filter(line => 
        line.startsWith('WORK:') || 
        line.startsWith('TIME:') || 
        line.startsWith('SIZE:') || 
        line.startsWith('PERF:')
    );
    return statsLines.join('\n');
}

// Export the main function for use in the bun script
export { main };

main();

// Parser.ts

export class Parser {
  protected input: string;
  protected pos: number;
  protected usedNames: Set<string>;

  constructor(input: string) {
    this.input = input;
    this.pos = 0;
    this.usedNames = new Set<string>();
  }

  protected skipWhitespace(): void {
    while (this.pos < this.input.length && /\s/.test(this.input[this.pos])) {
      this.pos++;
    }
  }

  protected skipComments(): void {
    this.skipWhitespace();
    while (
      this.pos < this.input.length - 1 &&
      this.input.substring(this.pos, this.pos + 2) === "//"
    ) {
      while (this.pos < this.input.length && this.input[this.pos] !== "\n") {
        this.pos++;
      }
      if (this.pos < this.input.length) this.pos++;
      this.skipWhitespace();
    }
  }

  protected skip(): void {
    this.skipWhitespace();
    this.skipComments();
  }

  protected isNameInit(c: string): boolean {
    return /[a-zA-Z_]/.test(c);
  }

  protected isNameChar(c: string): boolean {
    return /[a-zA-Z0-9_]/.test(c) || c === "$";
  }

  protected peek(pattern: string): boolean {
    this.skip();
    return this.input.substring(this.pos, this.pos + pattern.length) === pattern;
  }

  protected match(pattern: string): boolean {
    this.skip();
    if (this.input.substring(this.pos, this.pos + pattern.length) === pattern) {
      this.pos += pattern.length;
      return true;
    }
    return false;
  }

  protected error(message: string): never {
    throw new Error(`Parse error at position ${this.pos}: ${message}`);
  }

  protected symbol(sym: string): string {
    this.skip();
    if (this.match(sym)) {
      return sym;
    }
    this.error(`Expected symbol "${sym}"`);
    return ""; // Unreachable
  }
  
  protected fresh(base: string = "var"): string {
    let name = base;
    let counter = 1;
    while (this.usedNames.has(name)) {
      name = `${base}${counter}`;
      counter++;
    }
    this.usedNames.add(name);
    return name;
  }

  protected name(): string {
    this.skip();
    let startPos = this.pos;
    if (this.pos < this.input.length && this.isNameInit(this.input[this.pos])) {
      this.pos++;
      while (this.pos < this.input.length && this.isNameChar(this.input[this.pos])) {
        this.pos++;
      }
      const name = this.input.substring(startPos, this.pos);
      this.usedNames.add(name);
      return name;
    }
    this.error("Expected name");
    return ""; // Unreachable
  }

  protected parens<T>(parser: () => T): T {
    this.symbol("(");
    const result = parser();
    this.symbol(")");
    return result;
  }

  protected angles<T>(parser: () => T): T {
    this.symbol("<");
    const result = parser();
    this.symbol(">");
    return result;
  }

  protected braces<T>(parser: () => T): T {
    this.symbol("{");
    const result = parser();
    this.symbol("}");
    return result;
  }

  protected brackets<T>(parser: () => T): T {
    this.symbol("[");
    const result = parser();
    this.symbol("]");
    return result;
  }
}

// runLocal.ts

import { Term } from "./Term/Type";
import { readTerm } from "./Term/parse";
import { showTerm } from "./Term/show";
import { termToHVM } from "./Term/toHVM";
import { extractFunctionInfo, prettyTerm, findMet } from "./Term/pretty";
import * as net from 'net';
import * as fs from 'fs';
import * as path from 'path';
import { spawn } from 'child_process';

// Function to run HVM in a different directory with input piped to stdin
function runHVMWithInput(input: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const child = spawn(
      'hvm',
      ['run', 'Main.hvm', '-s', '-c', '-Q', '-C1', '"'+input+'"'],
      // ['run', 'Main.hvm', '-c', '-Q', '-C1', '"'+input+'"'],
      {
        cwd: '../kolmo-hvm',
        stdio: ['pipe', 'pipe', 'pipe'],
        shell: true,
      }
    );

    let output = '';
    let error = '';

    child.stdout.on('data', (data) => {
      output += data.toString();
    });

    child.stderr.on('data', (data) => {
      error += data.toString();
    });

    child.on('close', (code) => {
      if (code === 0) {
        resolve(output.trim());
      } else {
        console.log(output);
        console.log(error);
        reject(new Error(`Process exited with code ${code}: ${error}`));
      }
    });

    // Write the input to stdin and close it
    child.stdin.write(input + '\n');
    child.stdin.end();
  });
}

// Function to process a Kolmo file
async function processKolmoFile(filePath: string, command: string): Promise<void> {
  try {
    // Read the file
    const code = fs.readFileSync(filePath, 'utf8');
    
    // Parse the term
    const term: Term = readTerm(code);
    // return;
    
    // Convert to HVM
    const hvm: string = termToHVM(term);
    
    // Format for sending
    const hvmSingleLine = hvm
      .split('\n')
      .map(line => line.replace(/\/\/.*$/, '')) // remove everything after '//'
      .join(' ')                                // join lines with space
      .replace(/\s+/g, ' ')                     // normalize multiple spaces
      .trim();                                  // remove leading/trailing spaces
    
    // Wrap with the appropriate command constructor
    const wrappedHvm = `#${command}{${hvmSingleLine}}`;
    console.log(wrappedHvm);
    
    // Send to HVM server
    const result: string = await runHVMWithInput(wrappedHvm);
    if(result == "") {
      console.log("Did not found.");
      return;
    }
    console.log(result+'\n-----------------------------------\n');
    let resTerm = readTerm(result);

    let functionInfo = extractFunctionInfo(term, resTerm);
    let met = findMet(term);
    let formatted = prettyTerm(resTerm, met.T, functionInfo);
    console.log(formatted);

  } catch (err) {
    console.error('Error:', err);
    process.exit(1);
  }
}

// Main CLI function
function main(): void {
  const args = process.argv.slice(2);
  
  if (args.length < 2) {
    console.error('Usage: kolmo <command> <file.kolmo>');
    console.error('Commands:');
    console.error('  gen - Synthesizes a program via NeoGen');
    console.error('  chk - Type check the file');
    console.error('  run - Run the file');
    process.exit(1);
  }
  
  const command = args[0];
  const filePath = args[1];
  
  if (!['gen', 'chk', 'run'].includes(command)) {
    console.error('Error: Command must be one of: gen, chk, run');
    process.exit(1);
  }
  
  if (!fs.existsSync(filePath)) {
    console.error(`Error: File '${filePath}' does not exist.`);
    process.exit(1);
  }
  
  if (!filePath.endsWith('.kolmo')) {
    console.error('Error: File must have .kolmo extension.');
    process.exit(1);
  }
  
  // Convert command to capitalized form for the constructor
  const commandCap = command.charAt(0).toUpperCase() + command.slice(1);
  
  processKolmoFile(filePath, commandCap);
}

// Export the main function for use in the bun script
export { main };

main();

// Term/adjust.ts

import { Term } from "./Type";
import { etaReduce } from "./etaReduce";
import { linearize } from "./linearize";

export function adjust(term: Term): Term {
  return etaReduce(linearize(term));
}

// Term/eraReduce.ts

import { Term } from "./Type";
import { freeVars } from "./freeVars";

// Eta reduction: λx. (F x) -> F if x not free in F
export function etaReduce(term: Term): Term {
  switch (term.$) {
    case "Var":
    case "Idx":
    case "Set":
    case "Emp":
    case "Efq":
    case "Uni":
    case "One":
    case "Bit":
    case "Bt0":
    case "Bt1":
    case "Nat":
    case "Zer":
    case "Nil":
    case "Rfl":
    case "Tst":
      return term;
    
    case "Lam": {
      // First reduce the body
      const reducedBody = etaReduce(term.f);
      
      // Check if we can eta-reduce this lambda
      if (reducedBody.$ === "App" && 
          reducedBody.x.$ === "Var" && 
          reducedBody.x.k === term.k) {
        
        // Check if the parameter is not free in the function part
        const fFreeVars = freeVars(reducedBody.f);
        if (!fFreeVars.has(term.k)) {
          // Perform eta reduction
          return reducedBody.f;
        }
      }
      
      // If we can't eta-reduce, return the lambda with reduced body
      return { ...term, f: reducedBody };
    }
    
    case "App":
      return { ...term, f: etaReduce(term.f), x: etaReduce(term.x) };
    
    case "Sub":
      return { ...term, t: etaReduce(term.t) };
    
    case "Frz":
      return { ...term, x: etaReduce(term.x) };
    
    case "Ann":
      return { ...term, x: etaReduce(term.x), t: etaReduce(term.t) };
    
    case "Chk":
      return { ...term, x: etaReduce(term.x), t: etaReduce(term.t) };
    
    case "Met":
      return {
        ...term,
        T: etaReduce(term.T),
        C: term.C.map(c => etaReduce(c)),
        f: etaReduce(term.f)
      };
    
    case "Let":
      return {
        ...term,
        t: etaReduce(term.t),
        v: etaReduce(term.v),
        f: etaReduce(term.f)
      };
    
    case "Fix":
      return { ...term, f: etaReduce(term.f) };
    
    case "Use":
      return { ...term, f: etaReduce(term.f) };
    
    case "Bif":
      return { ...term, f: etaReduce(term.f), t: etaReduce(term.t) };
    
    case "Sig":
      return { ...term, a: etaReduce(term.a), b: etaReduce(term.b) };
    
    case "Tup":
      return { ...term, a: etaReduce(term.a), b: etaReduce(term.b) };
    
    case "Get":
      return { ...term, f: etaReduce(term.f) };
    
    case "All":
      return { ...term, a: etaReduce(term.a), b: etaReduce(term.b) };
    
    case "Fin":
      return { ...term, l: etaReduce(term.l) };
    
    case "Suc":
      return { ...term, n: etaReduce(term.n) };
    
    case "Add":
      return { ...term, a: etaReduce(term.a), b: etaReduce(term.b) };
    
    case "Swi":
      return { ...term, z: etaReduce(term.z), s: etaReduce(term.s) };
    
    case "Lst":
      return { ...term, t: etaReduce(term.t) };
    
    case "Vec":
      return { ...term, t: etaReduce(term.t), l: etaReduce(term.l) };
    
    case "Con":
      return { ...term, h: etaReduce(term.h), t: etaReduce(term.t) };
    
    case "Mat":
      return { ...term, n: etaReduce(term.n), c: etaReduce(term.c) };
    
    case "Eql":
      return { ...term, a: etaReduce(term.a), b: etaReduce(term.b), t: etaReduce(term.t) };
    
    case "Rwt":
      return { ...term, f: etaReduce(term.f) };
    
    default:
      return term;
  }
}

// Term/freeVars.ts

import { Term } from "./Type";

// Helper function to find free variables in a term
export function freeVars(term: Term, bound: Set<string> = new Set()): Set<string> {
  switch (term.$) {
    case "Var":
      return bound.has(term.k) ? new Set() : new Set([term.k]);
    case "Lam":
      const lamNewBound = new Set(bound);
      lamNewBound.add(term.k);
      return freeVars(term.f, lamNewBound);
    case "App":
      return new Set([...freeVars(term.f, bound), ...freeVars(term.x, bound)]);
    case "Let":
      const letVFreeVars = freeVars(term.v, bound);
      const letTFreeVars = freeVars(term.t, bound);
      const letNewBound = new Set(bound);
      letNewBound.add(term.x);
      return new Set([...letVFreeVars, ...letTFreeVars, ...freeVars(term.f, letNewBound)]);
    case "Fix":
      const fixNewBound = new Set(bound);
      fixNewBound.add(term.x);
      return freeVars(term.f, fixNewBound);
    case "Met":
      const metCFreeVars = term.C.reduce((acc, c) => 
        new Set([...acc, ...freeVars(c, bound)]), new Set<string>());
      const metNewBound = new Set(bound);
      metNewBound.add(term.x);
      return new Set([
        ...metCFreeVars, 
        ...freeVars(term.f, metNewBound),
        ...freeVars(term.T, bound)
      ]);
    case "Bif":
      return new Set([...freeVars(term.f, bound), ...freeVars(term.t, bound)]);
    case "Swi":
      return new Set([...freeVars(term.z, bound), ...freeVars(term.s, bound)]);
    case "Mat":
      return new Set([...freeVars(term.n, bound), ...freeVars(term.c, bound)]);
    // Handle other term types with subterms
    case "Idx":
      return freeVars(term.t, bound);
    case "Sub":
      return freeVars(term.t, bound);
    case "Frz":
      return freeVars(term.x, bound);
    case "Ann":
      return new Set([...freeVars(term.x, bound), ...freeVars(term.t, bound)]);
    case "Chk":
      return new Set([...freeVars(term.x, bound), ...freeVars(term.t, bound)]);
    case "Use":
      return freeVars(term.f, bound);
    case "Get":
      return freeVars(term.f, bound);
    case "Sig":
      return new Set([...freeVars(term.a, bound), ...freeVars(term.b, bound)]);
    case "Tup":
      return new Set([...freeVars(term.a, bound), ...freeVars(term.b, bound)]);
    case "All":
      return new Set([...freeVars(term.a, bound), ...freeVars(term.b, bound)]);
    case "Fin":
      return freeVars(term.l, bound);
    case "Suc":
      return freeVars(term.n, bound);
    case "Add":
      return new Set([...freeVars(term.a, bound), ...freeVars(term.b, bound)]);
    case "Lst":
      return freeVars(term.t, bound);
    case "Vec":
      return new Set([...freeVars(term.t, bound), ...freeVars(term.l, bound)]);
    case "Con":
      return new Set([...freeVars(term.h, bound), ...freeVars(term.t, bound)]);
    case "Eql":
      return new Set([...freeVars(term.a, bound), ...freeVars(term.b, bound), ...freeVars(term.t, bound)]);
    case "Rwt":
      return freeVars(term.f, bound);
    // Terminal cases (no variables)
    case "Set":
    case "Emp":
    case "Efq":
    case "Uni":
    case "One":
    case "Bit":
    case "Bt0":
    case "Bt1":
    case "Nat":
    case "Zer":
    case "Nil":
    case "Rfl":
    case "Tst":
      return new Set();
    default:
      return new Set();
  }
}

// Term/linearize.ts

import { Term } from "./Type";
import { freeVars } from "./freeVars";

export function linearize(term: Term): Term {
  switch (term.$) {
    case "App": {
      // Linearize both parts of the application
      const linearizedF = linearize(term.f);
      const linearizedX = linearize(term.x);
      
      // Only linearize if the function is a branch expression
      if (linearizedF.$ === "Bif" || linearizedF.$ === "Swi" || linearizedF.$ === "Mat") {
        // Extract branches based on the branch type
        let branches: Term[];
        if (linearizedF.$ === "Bif") {
          branches = [linearizedF.f, linearizedF.t];
        } else if (linearizedF.$ === "Swi") {
          branches = [linearizedF.z, linearizedF.s];
        } else { // Mat
          branches = [linearizedF.n, linearizedF.c];
        }
        
        // Find common free variables across all branches
        const freeSets = branches.map(branch => freeVars(branch));
        let commonVars: string[] = [];
        
        if (freeSets.length > 0) {
          // Start with all free vars from first branch
          commonVars = [...freeSets[0]];
          // Keep only those present in all branches
          for (let i = 1; i < freeSets.length; i++) {
            commonVars = commonVars.filter(v => freeSets[i].has(v));
          }
        }
        
        // Only proceed with linearization if there are common variables
        if (commonVars.length > 0) {
          // Wrap branches with lambdas for the common variables
          let wrappedBranches: Term[];
          
          if (linearizedF.$ === "Bif") {
            // For Bif, just wrap both branches with lambdas for common vars
            wrappedBranches = branches.map(branch => {
              let wrapped = branch;
              for (let i = commonVars.length - 1; i >= 0; i--) {
                wrapped = { $: "Lam", k: commonVars[i], f: wrapped };
              }
              return wrapped;
            });
          } else if (linearizedF.$ === "Swi") {
            // For Swi, special handling for successor case with pred lambda
            wrappedBranches = [];
            
            // Zero case - just wrap with lambdas for common vars
            let zeroWrapped = branches[0]; // z branch
            for (let i = commonVars.length - 1; i >= 0; i--) {
              zeroWrapped = { $: "Lam", k: commonVars[i], f: zeroWrapped };
            }
            wrappedBranches.push(zeroWrapped);
            
            // Successor case - special handling if it has a pred lambda
            const succBranch = branches[1]; // s branch
            if (succBranch.$ === "Lam") {
              // Has pred lambda - insert our common var lambdas AFTER it
              const predName = succBranch.k;
              let innerBody = succBranch.f;
              
              for (let i = commonVars.length - 1; i >= 0; i--) {
                innerBody = { $: "Lam", k: commonVars[i], f: innerBody };
              }
              
              wrappedBranches.push({ $: "Lam", k: predName, f: innerBody });
            } else {
              // No pred lambda - just wrap with lambdas for common vars
              let succWrapped : Term = succBranch;
              for (let i = commonVars.length - 1; i >= 0; i--) {
                succWrapped = { $: "Lam", k: commonVars[i], f: succWrapped };
              }
              wrappedBranches.push(succWrapped);
            }
          } else { // Mat
            // For Mat, special handling for cons case with head/tail lambdas
            wrappedBranches = [];
            
            // Nil case - just wrap with lambdas for common vars
            let nilWrapped = branches[0]; // n branch
            for (let i = commonVars.length - 1; i >= 0; i--) {
              nilWrapped = { $: "Lam", k: commonVars[i], f: nilWrapped };
            }
            wrappedBranches.push(nilWrapped);
            
            // Cons case - special handling if it has head/tail lambdas
            const consBranch = branches[1]; // c branch
            if (consBranch.$ === "Lam" && consBranch.f.$ === "Lam") {
              // Has head/tail lambdas - insert our common var lambdas AFTER them
              const headName = consBranch.k;
              const tailName = consBranch.f.k;
              let innerBody = consBranch.f.f;
              
              for (let i = commonVars.length - 1; i >= 0; i--) {
                innerBody = { $: "Lam", k: commonVars[i], f: innerBody };
              }
              
              wrappedBranches.push({ 
                $: "Lam", 
                k: headName, 
                f: { $: "Lam", k: tailName, f: innerBody } 
              });
            } else {
              // No head/tail lambdas - just wrap with lambdas for common vars
              let consWrapped = consBranch;
              for (let i = commonVars.length - 1; i >= 0; i--) {
                consWrapped = { $: "Lam", k: commonVars[i], f: consWrapped };
              }
              wrappedBranches.push(consWrapped);
            }
          }
          
          // Create new branch node with wrapped branches
          let newBranch: Term;
          if (linearizedF.$ === "Bif") {
            newBranch = { $: "Bif", f: wrappedBranches[0], t: wrappedBranches[1] };
          } else if (linearizedF.$ === "Swi") {
            newBranch = { $: "Swi", z: wrappedBranches[0], s: wrappedBranches[1] };
          } else { // Mat
            newBranch = { $: "Mat", n: wrappedBranches[0], c: wrappedBranches[1] };
          }
          
          // Apply the new branch node to the original argument
          let result: Term = { $: "App", f: newBranch, x: linearizedX };
          
          // Then apply to each common variable
          for (const varName of commonVars) {
            result = {
              $: "App",
              f: result,
              x: { $: "Var", k: varName }
            };
          }
          
          return result;
        }
      }
      
      // If not a branch application or no common variables,
      // just return a regular application with linearized parts
      return { $: "App", f: linearizedF, x: linearizedX };
    }
    
    // For all other terms, recursively linearize their subterms
    case "Bif":
      return { $: "Bif", f: linearize(term.f), t: linearize(term.t) };
    case "Swi":
      return { $: "Swi", z: linearize(term.z), s: linearize(term.s) };
    case "Mat":
      return { $: "Mat", n: linearize(term.n), c: linearize(term.c) };
    case "Lam":
      return { $: "Lam", k: term.k, f: linearize(term.f) };
    case "Sub":
      return { ...term, t: linearize(term.t) };
    case "Frz":
      return { ...term, x: linearize(term.x) };
    case "Ann":
      return { ...term, x: linearize(term.x), t: linearize(term.t) };
    case "Chk":
      return { ...term, x: linearize(term.x), t: linearize(term.t) };
    case "Met":
      return {
        ...term,
        T: linearize(term.T),
        C: term.C.map(c => linearize(c)),
        f: linearize(term.f)
      };
    case "Let":
      return {
        ...term,
        t: linearize(term.t),
        v: linearize(term.v),
        f: linearize(term.f)
      };
    case "Fix":
      return { ...term, f: linearize(term.f) };
    case "Use":
      return { ...term, f: linearize(term.f) };
    case "Sig":
      return { ...term, a: linearize(term.a), b: linearize(term.b) };
    case "Tup":
      return { ...term, a: linearize(term.a), b: linearize(term.b) };
    case "Get":
      return { ...term, f: linearize(term.f) };
    case "All":
      return { ...term, a: linearize(term.a), b: linearize(term.b) };
    case "Fin":
      return { ...term, l: linearize(term.l) };
    case "Suc":
      return { ...term, n: linearize(term.n) };
    case "Add":
      return { ...term, a: linearize(term.a), b: linearize(term.b) };
    case "Lst":
      return { ...term, t: linearize(term.t) };
    case "Vec":
      return { ...term, t: linearize(term.t), l: linearize(term.l) };
    case "Con":
      return { ...term, h: linearize(term.h), t: linearize(term.t) };
    case "Eql":
      return { ...term, a: linearize(term.a), b: linearize(term.b), t: linearize(term.t) };
    case "Rwt":
      return { ...term, f: linearize(term.f) };
    
    // Terminal cases (no changes needed)
    case "Var":
    case "Idx":
    case "Set":
    case "Emp":
    case "Efq":
    case "Uni":
    case "One":
    case "Bit":
    case "Bt0":
    case "Bt1":
    case "Nat":
    case "Zer":
    case "Nil":
    case "Rfl":
    case "Tst":
    default:
      return term;
  }
}

// Parse.ts

import { Parser } from "../Parser";
import { Term } from "./Type";
import { show } from "./show";
import { adjust } from "./adjust";
import { linearize } from "./linearize";
import { etaReduce } from "./etaReduce";

// Helper function to create natural numbers
function nat(n: number): Term {
  if (n === 0) {
    return { $: "Zer" };
  } else {
    return { $: "Suc", n: nat(n - 1) };
  }
}

// Function to convert position to line and column
function posToLineCol(pos: number, input: string): { line: number, col: number } {
  const lines = input.substring(0, pos).split('\n');
  const line = lines.length;
  const col = lines[lines.length - 1].length + 1;
  return { line, col };
}

// Highlight error in the code
function highlightError(pos: number, input: string): string {
  const { line, col } = posToLineCol(pos, input);
  const lines = input.split('\n');
  
  const numLen = String(Math.min(lines.length, line + 3)).length;
  const pad = (n: number) => ' '.repeat(Math.max(numLen - String(n).length, 0)) + n;
  
  let result = '';
  const startLine = Math.max(0, line - 3);
  const endLine = Math.min(lines.length - 1, line + 2);
  
  for (let i = startLine; i <= endLine; i++) {
    const currentLine = lines[i];
    const lineNum = i + 1;
    
    if (i + 1 === line) {
      const before = currentLine.substring(0, col - 1);
      const target = col <= currentLine.length ? currentLine.substring(col - 1, col) : ' ';
      const after = col <= currentLine.length ? currentLine.substring(col) : '';
      
      result += `${pad(lineNum)} | ${before}\x1b[31m\x1b[4m${target}\x1b[0m${after}\n`;
      result += `${' '.repeat(numLen)} | ${' '.repeat(col - 1)}\x1b[31m^\x1b[0m\n`;
    } else {
      result += `${pad(lineNum)} | ${currentLine}\n`;
    }
  }
  
  return result;
}

export class TermParser extends Parser {
  constructor(input: string) {
    super(input);
  }
  
  protected error(message: string): never {
    const { line, col } = posToLineCol(this.pos, this.input);
    const errorMsg = `\x1b[1mParse error at line ${line}, column ${col}:\x1b[0m\n${message}\n\n${highlightError(this.pos, this.input)}`;
    throw new Error(errorMsg);
  }

  public parse_term(): Term {
    const term = this.parse_term_ini();
    const end = this.parse_term_end(term);
    return end;
  }

  private parse_term_ini(): Term {
    this.skip();
    
    if (this.input.substring(this.pos).match(/^def\s/)) {
      return this.parse_definition();
    } else if (this.input.substring(this.pos).match(/^gen\s/)) {
      return this.parse_generation();
    } else if (this.input.substring(this.pos).match(/^let\s/)) {
      return this.parse_test();
    } else if (this.input.substring(this.pos).match(/^if\s/)) {
      return this.parse_if_then_else();
    } else if (this.input.substring(this.pos).match(/^switch\s/)) {
      return this.parse_switch();
    } else if (this.input.substring(this.pos).match(/^match\s/)) {
      return this.parse_match();
    } else if (this.input.substring(this.pos).match(/^view\s*\(/)) {
      return this.parse_view();
    }
    
    if (this.peek("λ") || this.peek("\\")) {
      this.pos++;
      if (this.peek("{")) {
        this.pos++;
        if (this.peek("}")) {
          this.pos++;
          return { $: "Efq" };
        } else if (this.peek("():")) {
          this.pos += 3;
          const f = this.parse_term();
          this.symbol("}");
          return { $: "Use", f };
        } else if (this.peek("#0:")) {
          this.pos += 3;
          const f = this.parse_term();
          this.symbol(";");
          this.symbol("#1:");
          const t = this.parse_term();
          this.symbol("}");
          return { $: "Bif", f, t };
        } else if (this.peek("(,):")) {
          this.pos += 4;
          const f = this.parse_term();
          this.symbol("}");
          return { $: "Get", f };
        } else if (this.peek("[]:")) {
          this.pos += 3;
          const n = this.parse_term();
          this.symbol(";");
          this.symbol("<>:");
          const c = this.parse_term();
          this.symbol("}");
          return { $: "Mat", n, c };
        } else if (this.peek("0:")) {
          this.pos += 2;
          const z = this.parse_term();
          this.symbol(";");
          this.symbol("+:");
          const s = this.parse_term();
          this.symbol("}");
          return { $: "Swi", z, s };
        } else if (this.peek("{=}:")) {
          this.pos += 4;
          const f = this.parse_term();
          this.symbol("}");
          return { $: "Rwt", f };
        }
      } else {
        const k = this.name();
        this.symbol(".");
        const body = this.parse_term();
        return { $: "Lam", k, f: body };
      }
    }
    
    if (this.peek("(")) {
      return this.parse_paren_expr();
    }
    else if (this.peek("[")) {
      return this.parse_list_literal();
    } else if (this.peek("∅")) {
      this.pos++;
      const x = this.parse_term();
      return { $: "Frz", x };
    } else if (this.peek("*")) {
      this.pos++;
      return { $: "Set" };
    } else if (this.peek("⊥")) {
      this.pos++;
      return { $: "Emp" };
    } else if (this.peek("⊤")) {
      this.pos++;
      return { $: "Uni" };
    } else if (this.peek("()")) {
      this.pos += 2;
      return { $: "One" };
    } else if (this.peek("𝔹")) {
      this.pos += "𝔹".length;
      return { $: "Bit" };
    } else if (this.peek("#0")) {
      this.pos += 2;
      return { $: "Bt0" };
    } else if (this.peek("#1")) {
      this.pos += 2;
      return { $: "Bt1" };
    } else if (this.peek("ℕ")) {
      this.pos += "ℕ".length;
      return { $: "Nat" };
    } else if (this.peek("0")) {
      this.pos++;
      return { $: "Zer" };
    } else if (this.peek("[]")) {
      this.pos += 2;
      return { $: "Nil" };
    } else if (this.peek("↑")) {
      this.pos++;
      const n = this.parse_term();
      return { $: "Suc", n };
    } else if (this.peek("^")) {
      this.pos++;
      const numStr = this.input.substring(this.pos).match(/^\d+/);
      if (!numStr) this.error("Expected number after '^'");
      this.pos += numStr[0].length;
      const i = parseInt(numStr[0], 10);
      this.symbol("<");
      const t = this.parse_term();
      this.symbol(">");
      return { $: "Idx", i, t };
    } else if (this.peek("Π") || this.peek("Pi")) {
      this.pos += this.peek("Π") ? 1 : 2;
      return this.parse_all();
    } else if (this.peek("Σ") || this.peek("Sigma")) {
      this.pos += this.peek("Σ") ? 1 : 5;
      return this.parse_sig();
    } else if (this.peek("<")) {
      return this.parse_ann();
    } else if (this.peek("!")) {
      this.pos++;
      return this.parse_let();
    } else if (this.peek("μ")) {
      this.pos++;
      return this.parse_fix();
    } else if (this.peek("?")) {
      this.pos++;
      return this.parse_met();
    } else if (this.peek("{")) {
      this.pos++;
      if (this.peek("=")) {
        this.pos++;
        this.symbol("}");
        return { $: "Rfl" };
      } else {
        const l = this.parse_term();
        this.symbol("}");
        return { $: "Fin", l };
      }
    } else if (this.input.substring(this.pos).match(/^1\+/)) {
      this.pos += 2;
      const n = this.parse_term();
      return { $: "Suc", n };
    } else if (this.pos < this.input.length && /[0-9]/.test(this.input[this.pos])) {
      const numStr = this.input.substring(this.pos).match(/^\d+/);
      if (numStr) {
        this.pos += numStr[0].length;
        const n = parseInt(numStr[0], 10);
        return nat(n);
      }
    } else if (this.pos < this.input.length && this.isNameInit(this.input[this.pos])) {
      return this.parse_var();
    }
    
    this.error("Invalid term");
    return { $: "Set" }; // Unreachable
  }
  
  private parse_paren_expr(): Term {
    const startPos = this.pos;
    this.symbol("(");
    
    if (this.peek(")")) {
      this.pos++;
      return { $: "One" };
    }
    
    const firstTerm = this.parse_term();
    this.skip();

    if (this.peek("&")) {
      let terms: Term[] = [firstTerm];
      while (this.peek("&")) {
        this.symbol("&");
        terms.push(this.parse_term());
      }
      this.symbol(")");

      let result = terms[terms.length - 1];
      for (let i = terms.length - 2; i >= 0; i--) {
        result = { $: "Sig", a: terms[i], b: { $: "Lam", k: "_", f: result } }
      }
      return result;
    }
    
    if (this.peek("->")) {
      let terms: Term[] = [firstTerm];
      while (this.peek("->")) {
        this.symbol("->");
        terms.push(this.parse_term());
      }
      this.symbol(")");

      let result = terms[terms.length - 1];
      for (let i = terms.length - 2; i >= 0; i--) {
        result = { $: "All", a: terms[i], b: { $: "Lam", k: "_", f: result } }
      }
      return result;
    }
    
    if (this.peek(",")) {
      let terms: Term[] = [firstTerm];
      while (this.peek(",")) {
        this.symbol(",");
        terms.push(this.parse_term());
      }
      this.symbol(")");

      let result = terms[terms.length - 1];
      for (let i = terms.length - 2; i >= 0; i--) {
        result = { $: "Tup", a: terms[i], b: result};
      }
      return result;
    }
    
    const terms: Term[] = [];
    while (!this.peek(")")) {
      terms.push(this.parse_term());
      this.skip();
    }
    
    this.symbol(")");
    
    if (terms.length === 0) {
      return firstTerm;
    }
    
    return terms.reduce((acc, term) => ({ $: "App", f: acc, x: term }), firstTerm);
  }

  private parse_term_end(term: Term): Term {
    this.skip();
    
    if (this.peek("==")) {
      this.pos += 2;
      const b = this.parse_term();
      this.symbol(":");
      const t = this.parse_term();
      return this.parse_term_end({ $: "Eql", a: term, b, t });
    } else if (this.peek("<>")) {
      this.pos += 2;
      const t = this.parse_term();
      return this.parse_term_end({ $: "Con", h: term, t });
    } else if (this.peek("::")) {
      this.pos += 2;
      const t = this.parse_term();
      return this.parse_term_end({ $: "Chk", x: term, t });
    } else if (this.peek("+")) {
      this.pos++;
      const b = this.parse_term();
      return this.parse_term_end({ $: "Add", a: term, b });
    } else if (this.peek("[")) {
      this.pos++;
      if (this.peek("]")) {
        this.pos++;
        return this.parse_term_end({ $: "Lst", t: term });
      } else {
        const l = this.parse_term();
        this.symbol("]");
        return this.parse_term_end({ $: "Vec", t: term, l });
      }
    } else if (this.peek("(")) {
      const startPos = this.pos;
      const prevChar = this.pos > 0 ? this.input[this.pos - 1] : '';
      if (/\s/.test(prevChar)) {
        return term;
      }
      
      this.pos++;
      const args: Term[] = [];

      if (!this.peek(")")) {
        const firstArg = this.parse_term();
        this.skip();
        
        if (this.peek(",")) {
          this.pos++;
          this.skip();
          args.push(firstArg);
          
          while(true) {
            args.push(this.parse_term());
            this.skip();
            if (this.peek(",")) {
              this.pos++;
              this.skip();
            } else {
              break;
            }
          }
        } else if (this.peek(")")) {
          args.push(firstArg);
        } else {
          this.pos = startPos;
          return term;
        }
      }
      
      this.symbol(")");
      
      let result = term;
      for (const arg of args) {
        result = { $: "App", f: result, x: arg };
      }
      
      return this.parse_term_end(result);
    } else if (this.peek("=")) {
      if (term.$ === "Var") {
        const varName = term.k;
        this.pos++;
        const value = this.parse_term();
        
        const nextTerm = this.parse_term();
        return {
          $: "Let",
          x: varName,
          t: { $: "Set" },
          v: value,
          f: nextTerm
        };
      }
    }
    
    return term;
  }

  private parse_var(): Term {
    const k = this.name();
    switch (k) {
      case "Nat": return { $: "Nat" };
      case "Bit": return { $: "Bit" };
      case "Set": return { $: "Set" };
      case "False": return { $: "Bt0" };
      case "True": return { $: "Bt1" };
      default: return { $: "Var", k };
    }
  }

  private parse_app(): Term {
    this.symbol("(");
    const f = this.parse_term();
    const xs: Term[] = [];
    
    this.skip();
    while (this.pos < this.input.length && !this.peek(")")) {
      xs.push(this.parse_term());
      this.skip();
    }

    this.symbol(")");
    return xs.reduce((acc, x) => ({ $: "App", f: acc, x }), f);
  }

  private parse_all(): Term {
    if (this.peek("(")) {
      this.symbol("(");
      const x = this.name();
      this.symbol(":");
      const A = this.parse_term();
      this.symbol(")");
      this.symbol(".");
      const B = this.parse_term();
      return { $: "All", a: A, b: { $: "Lam", k: x, f: B } };
    } else {
      const x = "_";
      const A = this.parse_term();
      this.symbol(".");
      const B = this.parse_term();
      return { $: "All", a: A, b: { $: "Lam", k: x, f: B } };
    }
  }

  private parse_sig(): Term {
    if (this.peek("(")) {
      this.symbol("(");
      const x = this.name();
      this.symbol(":");
      const A = this.parse_term();
      this.symbol(")");
      this.symbol(".");
      const B = this.parse_term();
      return { $: "Sig", a: A, b: { $: "Lam", k: x, f: B } };
    } else {
      const x = "_";
      const A = this.parse_term();
      this.symbol(".");
      const B = this.parse_term();
      return { $: "Sig", a: A, b: { $: "Lam", k: x, f: B } };
    }
  }

  private parse_ann(): Term {
    this.symbol("<");
    const x = this.parse_term();
    this.symbol(":");
    const t = this.parse_term();
    this.symbol(">");
    return { $: "Ann", x, t };
  }

  private parse_let(): Term {
    const x = this.name();
    this.symbol(":");
    const t = this.parse_term();
    this.symbol("=");
    const v = this.parse_term();
    this.symbol(";");
    const body = this.parse_term();
    return { $: "Let", x, t, v, f: body };
  }

  private parse_fix(): Term {
    const x = this.name();
    this.symbol(".");
    const body = this.parse_term();
    return { $: "Fix", x, f: body };
  }

  private parse_met(): Term {
    const x = this.name();
    this.symbol(":");
    const T = this.parse_term();
    let S = "";
    if (this.peek("#")) {
      this.pos++;
      const seedStr = this.input.substring(this.pos).match(/^[01]+/);
      if (seedStr) {
        S = seedStr[0];
        this.pos += S.length;
      }
    }
    const C: Term[] = [];
    if (this.peek("{")) {
      this.pos++;
      while (!this.peek("}")) {
        C.push(this.parse_term());
        if (this.peek(",")) {
          this.pos++;
        } else {
          break;
        }
      }
      this.symbol("}");
    }
    this.symbol(";");
    const body = this.parse_term();
    return { $: "Met", x, T, S, C, f: body };
  }
  
  private parse_list_literal(): Term {
    this.symbol("[");
    if (this.peek("]")) {
      this.pos++;
      return { $: "Nil" };
    }
    
    const elements: Term[] = [];
    
    while (true) {
      elements.push(this.parse_term());
      
      if (this.peek(",")) {
        this.pos++;
      } else {
        break;
      }
    }
    
    this.symbol("]");
    
    let result: Term = { $: "Nil" };
    for (let i = elements.length - 1; i >= 0; i--) {
      result = { $: "Con", h: elements[i], t: result };
    }
    
    return result;
  }
  
  private parse_definition(): Term {
    const defPos = this.pos;
    if (!this.input.substring(this.pos).match(/^def\s/)) {
      this.pos = defPos;
      this.error("Expected 'def' keyword");
    }
    this.pos += 3;
    this.skip();
    
    const name = this.name();
    this.symbol("(");
    
    const args: {name: string, type: Term}[] = [];
    while (!this.peek(")")) {
      const argName = this.name();
      this.symbol(":");
      const argType = this.parse_term();
      args.push({name: argName, type: argType});
      
      if (this.peek(",")) {
        this.pos++;
      } else {
        break;
      }
    }
    this.symbol(")");
    
    this.symbol("->");
    const returnType = this.parse_term();
    this.symbol(":");
    
    const body = this.parse_term();
    
    let piType: Term = returnType;
    for (let i = args.length - 1; i >= 0; i--) {
      const arg = args[i];
      piType = { 
        $: "All", 
        a: arg.type, 
        b: { $: "Lam", k: arg.name, f: piType } 
      };
    }
    
    let lambdaBody = body;
    for (let i = args.length - 1; i >= 0; i--) {
      lambdaBody = {
        $: "Lam",
        k: args[i].name,
        f: lambdaBody
      };
    }
    
    const nextTerm = this.parse_term();
    const ret : Term = {
      $: "Let",
      x: name,
      t: piType,
      v: {
        $: "Fix",
        x: name,
        f: lambdaBody
      },
      f: nextTerm
    };
    return adjust(ret);
  }

  private parse_generation(): Term {
    const genPos = this.pos;
    if (!this.input.substring(this.pos).match(/^gen\s/)) {
      this.pos = genPos;
      this.error("Expected 'gen' keyword");
    }
    this.pos += 3;
    this.skip();
    
    const name = this.name();
    this.symbol("(");
    
    const args: {name: string, type: Term}[] = [];
    while (!this.peek(")")) {
      const argName = this.name();
      this.symbol(":");
      const argType = this.parse_term();
      args.push({name: argName, type: argType});
      if (this.peek(",")) {
        this.pos++;
      } else {
        break;
      }
    }
    this.symbol(")");
    
    this.symbol("->");
    const returnType = this.parse_term();
    
    let piType: Term = returnType;
    for (let i = args.length - 1; i >= 0; i--) {
      const arg = args[i];
      piType = { 
        $: "All", 
        a: arg.type, 
        b: { $: "Lam", k: arg.name, f: piType }
      };
    }
    
    let seed = "";
    this.skip();
    if (this.input.substring(this.pos).match(/^seed\s/)) {
      this.pos += 4;
      this.skip();
      
      if (this.peek("#")) {
        this.pos++;
        const seedStr = this.input.substring(this.pos).match(/^[01]+/);
        if (seedStr) {
          seed = seedStr[0];
          this.pos += seed.length;
        }
      }
    }
    
    const context: Term[] = [];
    this.skip();
    while (this.input.substring(this.pos).match(/^with\s/)) {
      this.pos += 4;
      this.skip();
      
      context.push(this.parse_term());
      this.skip();
    }
    
    const nextTerm = this.parse_term();
    return {
      $: "Met",
      x: name,
      T: piType,
      S: seed,
      C: context,
      f: nextTerm
    };
  }
  
  // private parse_test(): Term {
  //   const testPos = this.pos;
  //   if (!this.input.substring(this.pos).match(/^let\s/)) {
  //     this.pos = testPos;
  //     this.error("Expected test to start with 'let'");
  //   }
  //   this.pos += 3;
  //   this.skip();
  //
  //   const eql = this.parse_term();
  //
  //   const nextTerm = this.parse_term();
  //   return {
  //     $: "Let",
  //     x: "_",
  //     t: eql,
  //     v: { $: "Rfl" },
  //     f: nextTerm
  //   };
  // }
  
  private parse_test(): Term {
    const testPos = this.pos;
    if (!this.input.substring(this.pos).match(/^let\s/)) {
      this.pos = testPos;
      this.error("Expected test to start with 'let'");
    }
    this.pos += 3;
    this.skip();
    
    let eqls: Term[];
    if (this.peek("{")) {
      this.pos++;
      eqls = [];
      let lhs: Term[] = [];
      let rhs: Term[] = [];
      while (!this.peek("}")) {
        lhs.push(this.parse_term());
        this.symbol("==");
        rhs.push(this.parse_term());
        if (this.peek(";")) {
          this.pos++;
          this.skip();
        } else if (!this.peek("}")) {
          this.error("Expected ';' or '}'");
        }
      }
      this.symbol("}");
      this.symbol(":");
      const t = this.parse_term();
      for (let i = 0; i < lhs.length; i++) {
        eqls.push({$: "Eql", a: lhs[i], b: rhs[i], t});
      }
    } else {
      const eql = this.parse_term();
      eqls = [eql];
    }

    const body = this.parse_term();
    
    let result = body;
    for (let i = eqls.length - 1; i >= 0; i--) {
      result = {
        $: "Let",
        x: "_",
        t: eqls[i],
        v: { $: "Tst" },
        f: result
      };
    }
    return result;
  }


  private parse_if_then_else(): Term {
    const ifPos = this.pos;
    if (!this.input.substring(this.pos).match(/^if\s/)) {
      this.pos = ifPos;
      this.error("Expected 'if' keyword");
    }
    this.pos += 2;
    this.skip();
    
    const condition = this.parse_term();
    this.symbol(":");
    
    const thenBranch = this.parse_term();
    
    const elsePos = this.pos;
    this.skip();
    if (!this.input.substring(this.pos).match("else")) {
      this.pos = elsePos;
      this.error("Expected 'else' keyword after then branch");
    }
    this.pos += 4;
    this.skip();
    
    this.symbol(":");
    const elseBranch = this.parse_term();
    
    return {
      $: "App",
      f: {
        $: "Bif",
        f: elseBranch,
        t: thenBranch
      },
      x: condition
    };
  }
  
  private parse_switch(): Term {
    const switchPos = this.pos;
    if (!this.input.substring(this.pos).match(/^switch\s/)) {
      this.pos = switchPos;
      this.error("Expected 'switch' keyword");
    }
    this.pos += 6;
    this.skip();
    
    const scrutinee = this.parse_term();
    this.symbol(":");
    
    const case0Pos = this.pos;
    this.skip();
    if (!this.input.substring(this.pos).match(/^case\s/)) {
      this.pos = case0Pos;
      this.error("Expected 'case' keyword for zero case");
    }
    this.pos += 4;
    this.skip();
    
    if (!this.peek("0")) {
      this.error("Expected '0' for switch's zero case");
    }
    this.pos++;
    
    this.symbol(":");
    const zeroCase = this.parse_term();
    
    const case1Pos = this.pos;
    this.skip();
    if (!this.input.substring(this.pos).match(/^case\s/)) {
      this.pos = case1Pos;
      this.error("Expected 'case' keyword for successor case");
    }
    this.pos += 4;
    this.skip();
    
    if (!this.peek("1")) {
      this.error("Expected '1' for switch's successor case");
    }
    this.pos++;
    this.skip();
    
    if (!this.peek("+")) {
      this.error("Expected '+' after '1' in switch's successor case");
    }
    this.pos++;
    this.skip();
    
    const predName = this.name();
    this.symbol(":");
    const succCase = this.parse_term();
    
    return {
      $: "App",
      f: {
        $: "Swi",
        z: zeroCase,
        s: { 
          $: "Lam", 
          k: predName, 
          f: succCase 
        }
      },
      x: scrutinee
    };
  }
  
  private parse_match(): Term {
    const matchPos = this.pos;
    if (!this.input.substring(this.pos).match(/^match\s/)) {
      this.pos = matchPos;
      this.error("Expected 'match' keyword");
    }
    this.pos += 5;
    this.skip();
    
    const scrutinee = this.parse_term();
    this.symbol(":");
    
    const firstCase = this.pos;
    this.skip();
    if (!this.input.substring(this.pos).match(/^case\s/)) {
      this.pos = firstCase;
      this.error("Expected 'case' keyword for first case");
    }
    this.pos += 4;
    this.skip();

    // here we check for pair or list
    if (this.peek("[")) {
      // parse as a match on list
      this.pos++;
      if(!this.peek("]")) {
        this.error("Expected ']' after '[' in match's nil case");
      }
      this.pos++;
      this.symbol(":");

      const nilCase = this.parse_term();
      const caseConsPos = this.pos;
      this.skip();

      if (!this.input.substring(this.pos).match(/^case\s/)) {
        this.pos = caseConsPos;
        this.error("Expected 'case' keyword for cons case");
      }

      this.pos += 4;
      this.skip();
      
      const headName = this.name();
      this.skip();

      if (!this.peek("<>")) {
        this.error("Expected '<>' after head name in match's cons case");
      }
      this.pos += 2;
      this.skip();
      
      const tailName = this.name();
      this.symbol(":");
      const consCase = this.parse_term();
      
      const headLambda: Term = {
        $: "Lam",
        k: headName,
        f: {
          $: "Lam",
          k: tailName,
          f: consCase
        }
      };
      
      return {
        $: "App",
        f: {
          $: "Mat",
          n: nilCase,
          c: headLambda
        },
        x: scrutinee
      };
 
    } else if (this.peek("(")) {
      // parse as a match on tuple
      this.pos++;
      const lft = this.name();
      this.skip();
      if (!this.peek(",")) {
        this.error("Expected ',' separating pair lft and rg");
      }
      this.pos++;
      const rgt = this.name();
      this.symbol(")");
      this.symbol(":");
      const bod = this.parse_term();

      const lftLam : Term = {
        $: "Lam",
        k: lft,
        f: {
          $: "Lam",
          k: rgt,
          f: bod
        }
      }

      return {
        $: "App",
        f: {
          $: "Get",
          f: lftLam
        },
        x: scrutinee
      };

    } else {
      this.error("Expected '[' or '(' for match on pair or list.");
    } 
  }

  private parse_view(): Term {
    const viewMatch = this.input.substring(this.pos).match(/^view\s*\(/);
    this.pos += viewMatch![0].length;
    this.skip();
    
    const name = this.name();
    
    this.symbol(")");
    
    return { $: "Frz", x: { $: "Var", k: name + "$" } };
  }
}

export function parse(file: string, code: string): Term | Error {
  const parser = new TermParser(code);
  try {
    return parser.parse_term();
  } catch (e) {
    return e as Error;
  }
}

export function readTerm(input: string): Term {
  const result = parse("no-file", input);
  if (result instanceof Error) {
    console.log(result.toString());
    process.exit();
  }
  return result;
}

export const parseTerm = parse;

// Pretty.ts

import { Term } from "./Type";

interface ArgInfo {
  name: string;
  type: Term;
}

interface FunctionInfo {
  name: string;
  aux: string[];
  args: ArgInfo[];
}

interface Context {
  names: Map<string, string>; // Maps lambda parameters to formatted names
  indent: number;
  freshVarCounters: Map<string, number>; // For generating fresh variable names
}

// Main entry point for formatting
export function prettyTerm(term: Term, type: Term, info: FunctionInfo): string {
  // Unwrap any Frz wrapper
  term = unwrapFrz(term);
  
  // Initialize context
  const ctx: Context = {
    names: new Map(),
    indent: 0,
    freshVarCounters: new Map(),
  };
  
  // Process auxiliary functions
  for (const auxName of info.aux) {
    if (term.$ === "Lam") {
      ctx.names.set(term.k, auxName);
      term = term.f;
    }
  }
  
  // Process recursive binding (function name itself)
  if (term.$ === "Lam") {
    ctx.names.set(term.k, info.name);
    term = term.f;
  }
  
  // Generate function signature
  const returnType = extractReturnType(type, info.args.length);
  let result = formatSignature(info, returnType);
  
  // Format the body with remaining arguments
  const remainingArgs = info.args.map(arg => arg.name);
  ctx.indent = 1;
  result += formatBody(term, ctx, info, remainingArgs);
  
  return result;
}

// Unwrap Frz terms
function unwrapFrz(term: Term): Term {
  if (term.$ === "Frz") {
    return unwrapFrz(term.x);
  }
  return term;
}

// Generate a unique variable name
function freshVar(ctx: Context, base: string = 'n'): string {
  const counter = ctx.freshVarCounters.get(base) || 0;
  ctx.freshVarCounters.set(base, counter + 1);
  return counter === 0 ? base : `${base}${counter}`;
}

// Format the term body recursively
function formatBody(term: Term, ctx: Context, info: FunctionInfo, remainingArgs: string[]): string {
  const indentation = "  ".repeat(ctx.indent);
  
  if (term.$ === "Lam") {
    if (remainingArgs.length > 0) {
      const argName = remainingArgs[0];
      ctx.names.set(term.k, argName);
      return formatBody(term.f, ctx, info, remainingArgs.slice(1));
    } else {
      const varName = freshVar(ctx, term.k.charAt(0));
      ctx.names.set(term.k, varName);
      return formatBody(term.f, ctx, info, remainingArgs);
    }
  }
  
  switch (term.$) {
    case "Var": {
      const name = ctx.names.get(term.k) || term.k;
      return `${indentation}${name}`;
    }
    
    case "Swi": {
      return formatSwitch(term, ctx, info, remainingArgs);
    }

    case "Get": {
      return formatGet(term, ctx, info, remainingArgs);
    }
    
    case "Mat": {
      return formatMatch(term, ctx, info, remainingArgs);
    }

    case "Bif": {
      return formatBif(term, ctx, info, remainingArgs);
    }
    
    case "Suc": {
      return `${indentation}1+${formatExpr(term.n, ctx, info)}`;
    }
    
    case "Zer": {
      return `${indentation}0`;
    }
    
    case "App": {
      return formatApplication(term, ctx, info);
    }
    
    case "Nil": {
      return `${indentation}[]`;
    }
    
    case "Con": {
      const head = formatExpr(term.h, ctx, info);
      const tail = formatExpr(term.t, ctx, info);
      return `${indentation}${head} <> ${tail}`;
    }
    
    case "Add": {
      const a = formatExpr(term.a, ctx, info);
      const b = formatExpr(term.b, ctx, info);
      return `${indentation}${a} + ${b}`;
    }
    
    case "Bt0": {
      return `${indentation}False`;
    }
    
    case "Bt1": {
      return `${indentation}True`;
    }

    case "Tup": {
      const a = formatExpr(term.a, ctx, info);
      const b = formatExpr(term.b, ctx, info);
      return `${indentation}(${a} , ${b})`;
    }

    case "Emp": {
      return `${indentation}⊥`
    }
    
    default: {
      return `${indentation}<${term.$}>`;
    }
  }
}

// Format a switch expression
function formatSwitch(term: Extract<Term, { $: "Swi" }>, ctx: Context, info: FunctionInfo, remainingArgs: string[]): string {
  const indentation = "  ".repeat(ctx.indent);
  
  if (remainingArgs.length === 0) {
    throw new Error("No remaining argument for switch");
  }
  
  const scrutinee = remainingArgs[0];
  let result = `${indentation}switch ${scrutinee}:\n`;
  
  // Zero case: process with remaining args after scrutinee
  const zeroRemainingArgs = remainingArgs.slice(1);
  const zeroCtx = { ...ctx, indent: ctx.indent + 2, names: new Map(ctx.names) };
  result += `${indentation}  case 0:\n`;
  result += formatBody(term.z, zeroCtx, info, zeroRemainingArgs) + "\n";
  
  // Successor case: introduce predecessor, then process with remaining args after scrutinee
  const predVar = freshVar(ctx, 'n');

  const sucCtx = { ...ctx, indent: ctx.indent + 2, names: new Map(ctx.names) };
  result += `${indentation}  case 1+${predVar}:\n`;

  if (term.s.$ == "Lam") {
    sucCtx.names.set(term.s.k, predVar);
    result += formatBody(term.s.f, sucCtx, info, remainingArgs.slice(1));
  } else if (term.s.$ == "Swi") {
    const remaining = remainingArgs.slice(1);
    remaining.unshift(predVar); 
    result += formatSwitch(term.s, sucCtx, info, remaining);
  } else {
    throw new Error("Expected Swi or Lam");
  }
  return result;
}

function formatGet(term: Extract<Term, { $: "Get" }>, ctx: Context, info: FunctionInfo, remainingArgs: string[]): string {
  const indentation = "  ".repeat(ctx.indent);
  
  if (remainingArgs.length === 0) {
    throw new Error("No remaining argument for Get");
  }
  
  const scrutinee = remainingArgs[0];
  let result = `${indentation}match ${scrutinee}:\n`;

  // Successor case: introduce predecessor, then process with remaining args after scrutinee
  const lftVar = freshVar(ctx, 'lft');
  const rgtVar = freshVar(ctx, 'rgt');
  if (term.f.$ !== "Lam") {
    throw new Error("Expected lambda for injection left.");
  } else if (term.f.f.$ != "Lam") {
    throw new Error("Expected lambda for injection right.");
  }
  const getCtx = { ...ctx, indent: ctx.indent + 2, names: new Map(ctx.names) };
  getCtx.names.set(term.f.k, lftVar);
  getCtx.names.set(term.f.f.k, rgtVar);
  result += `${indentation}  case (${lftVar} ,  ${rgtVar}):\n`;
  result += formatBody(term.f.f.f, getCtx, info, remainingArgs.slice(1));
  return result;
}

// Format a list match expression
function formatMatch(term: Extract<Term, { $: "Mat" }>, ctx: Context, info: FunctionInfo, remainingArgs: string[]): string {
  const indentation = "  ".repeat(ctx.indent);
  
  if (remainingArgs.length === 0) {
    throw new Error("No remaining argument for match");
  }
  
  const scrutinee = remainingArgs[0];
  let result = `${indentation}match ${scrutinee}:\n`;
  
  // Nil case
  const nilRemainingArgs = remainingArgs.slice(1);
  const nilCtx = { ...ctx, indent: ctx.indent + 2, names: new Map(ctx.names) };
  result += `${indentation}  case []:\n`;
  result += formatBody(term.n, nilCtx, info, nilRemainingArgs) + "\n";
  
  // Cons case
  const headVar = freshVar(ctx, 'h');
  const tailVar = freshVar(ctx, 't');
  const consCtx = { ...ctx, indent: ctx.indent + 2, names: new Map(ctx.names) };
  result += `${indentation}  case ${headVar} <> ${tailVar}:\n`;
  
  if (term.c.$ === "Lam") {
    consCtx.names.set(term.c.k, headVar);
    if (term.c.f.$ === "Lam") {
      consCtx.names.set(term.c.f.k, tailVar);
      result += formatBody(term.c.f.f, consCtx, info, remainingArgs.slice(1));
    } else if (term.c.f.$ === "Mat") {
      const remaining = remainingArgs.slice(1);
      remaining.unshift(tailVar);
      result += formatMatch(term.c.f, consCtx, info, remaining);
    } else if (term.c.f.$ === "Swi") {
      const remaining = remainingArgs.slice(1);
      remaining.unshift(tailVar);
      result += formatSwitch(term.c.f, consCtx, info, remaining);
    } else if (term.c.f.$ === "Get") {
      const remaining = remainingArgs.slice(1);
      remaining.unshift(tailVar);
      result += formatBody(term.c.f, consCtx, info, remaining);
    }  else if (term.c.f.$ === "Bif") {
      const remaining = remainingArgs.slice(1);
      remaining.unshift(tailVar);
      result += formatBif(term.c.f, consCtx, info, remaining);
    } else {
      result += formatBody(term.c.f, consCtx, info, remainingArgs.slice(1));
    }
  } else if (term.c.$ === "Swi") {
    const remaining = remainingArgs.slice(1);
    remaining.unshift(headVar, tailVar);
    result += formatSwitch(term.c, consCtx, info, remaining);
  } else if (term.c.$ === "Mat") {
    const remaining = remainingArgs.slice(1);
    remaining.unshift(headVar, tailVar);
    result += formatMatch(term.c, consCtx, info, remaining);
  } else if (term.c.$ === "Bif") {
    const remaining = remainingArgs.slice(1);
    remaining.unshift(headVar, tailVar);
    result += formatBif(term.c, consCtx, info, remaining);
  } else if (term.c.$ === "Get") {
    const remaining = remainingArgs.slice(1);
    remaining.unshift(headVar, tailVar);
    result += formatBody(term.c, consCtx, info, remaining);
  } else {
    throw new Error("Expected Lam, Swi, Mat, Bif, or Get for cons case");
  }
  
  return result;
}

function formatBif(term: Extract<Term, { $: "Bif" }>, ctx: Context, info: FunctionInfo, remainingArgs: string[]): string {
  const indentation = "  ".repeat(ctx.indent);
  
  if (remainingArgs.length === 0) {
    throw new Error("No remaining argument for Bif");
  }
  
  const scrutinee = remainingArgs[0];
  let result = `${indentation}if ${scrutinee}:\n`;
  
  const trueCtx = { ...ctx, indent: ctx.indent + 1, names: new Map(ctx.names) };
  // result += `${indentation}  case True:\n`;
  result += formatBody(term.t, trueCtx, info, remainingArgs.slice(1)) + "\n";
  
  const falseCtx = { ...ctx, indent: ctx.indent + 1, names: new Map(ctx.names) };
  result += `${indentation}else:\n`;
  result += formatBody(term.f, falseCtx, info, remainingArgs.slice(1));
  
  return result;
}

// Format expressions without indentation
function formatExpr(term: Term, ctx: Context, info: FunctionInfo): string {
  switch (term.$) {
    case "Var": {
      return ctx.names.get(term.k) || term.k;
    }
    case "Suc": {
      return `1+${formatExpr(term.n, ctx, info)}`;
    }
    case "Zer": {
      return "0";
    }
    case "App": {
      const parts = collectAppParts(term);
      const func = formatExpr(parts[0], ctx, info);
      const args = parts.slice(1).map(arg => formatExpr(arg, ctx, info)).join(", ");
      return `${func}(${args})`;
    }
    case "Nil": {
      return "[]";
    }
    case "Con": {
      const head = formatExpr(term.h, ctx, info);
      const tail = formatExpr(term.t, ctx, info);
      return `${head} <> ${tail}`;
    }
    case "Add": {
      const a = formatExpr(term.a, ctx, info);
      const b = formatExpr(term.b, ctx, info);
      return `${a} + ${b}`;
    }
    case "Bt0": {
      return "False";
    }
    case "Bt1": {
      return "True";
    }
    case "Tup": {
      const a = formatExpr(term.a, ctx, info);
      const b = formatExpr(term.b, ctx, info);
      return `(${a} , ${b})`;
    }
    default: {
      return `<${term.$}>`;
    }
  }
}

// Format a function application
function formatApplication(term: Term, ctx: Context, info: FunctionInfo): string {
  const indentation = "  ".repeat(ctx.indent);
  const parts = collectAppParts(term);
  
  if (parts.length === 0) {
    return `${indentation}<invalid-application>`;
  }
  
  const func = parts[0];
  const args = parts.slice(1);
  
  let funcName = func.$ === "Var" ? (ctx.names.get(func.k) || func.k) : formatExpr(func, ctx, info);
  const formattedArgs = args.map(arg => formatExpr(arg, ctx, info)).join(", ");
  return `${indentation}${funcName}(${formattedArgs})`;
}

// Helper to collect all arguments from a nested application
function collectAppParts(term: Term): Term[] {
  if (term.$ !== "App") {
    return [term];
  }
  
  const result: Term[] = [];
  let current: Term = term;
  
  while (current.$ === "App") {
    result.unshift(current.x);
    current = current.f;
  }
  
  result.unshift(current);
  return result;
}

// Helper to format the function signature
function formatSignature(info: FunctionInfo, returnType: Term): string {
  const args = info.args.map(arg => `${arg.name}: ${formatType(arg.type)}`).join(", ");
  return `def ${info.name}(${args}) -> ${formatType(returnType)}:\n`;
}

// Helper to format type expressions
function formatType(type: Term): string {
  switch (type.$) {
    case "Emp": return "⊥";
    case "Nat": return "Nat";
    case "Bit": return "Bit";
    case "Lst": return `${formatType(type.t)}[]`;
    case "All": {
      if (type.b.$ === "Lam") {
        return `${formatType(type.a)} -> ${formatType(type.b.f)}`;
      } else {
        return `${formatType(type.a)} -> ${formatType(type.b)}`;
      }
    }
    case "Sig": {
      if (type.b.$ === "Lam") {
        if(type.b.k === "_") {
          return `(${formatType(type.a)} & ${formatType(type.b.f)})`;
        }
        return `Σ (${type.b.k} : ${formatType(type.a)}). ${formatType(type.b.f)}`;
      }
      return `(${formatType(type.a)} & ${formatType(type.b)})`;
    }
    case "Set": return "*";
    case "Var": return type.k;
    default: return type.$.toString();
  }
}

// Extract the return type from a function type
function extractReturnType(type: Term, argsCount: number): Term {
  let current = type;
  for (let i = 0; i < argsCount; i++) {
    if (current.$ !== "All") return current;
    current = current.b.$ === "Lam" ? current.b.f : current.b;
  }
  return current;
}

// Existing helper functions for FunctionInfo extraction remain unchanged

// Function to extract function info from a term
export function extractFunctionInfo(term: Term, type: Term): FunctionInfo {
  // Find Met in the term
  const met = findMet(term);
  const name = met.x;
  const aux = met.C.flatMap(v => v.$ === "Var" ? [v.k] : []);
  
  // Extract argument names and types from the Pi type
  const args: ArgInfo[] = [];
  let currentType = met.T;
  
  // Generate unique argument names based on position
  const varNames = 'abcdefghijklmnopqrstuvwxyz';
  let varIndex = 0;
  let usedNames = new Set<string>();
  
  while (currentType.$ === "All") {
    const argType = currentType.a;
    
    // Generate a unique argument name
    let varName: string;
    do {
      varName = varNames[varIndex++ % varNames.length];
      if (varIndex > 26) {
        varName += Math.floor(varIndex / 26);
      }
    } while (usedNames.has(varName));
    
    usedNames.add(varName);
    
    args.push({
      name: varName,
      type: argType
    });
    
    // Move to next type
    if (currentType.b.$ === "Lam") {
      currentType = currentType.b.f;
    } else {
      currentType = currentType.b;
    }
  }
  
  return { name, aux, args };
}

// Find Met in a term
export function findMet(term: Term): Extract<Term, { $: "Met" }> {
  switch(term.$) {
    case "Met": return term;
    case "Idx":
    case "Sub":
      return findMet(term.t);
    case "Frz":
      return findMet(term.x);
    case "Let":
    case "Fix":
      return findMet(term.f);
    default: throw Error("Met not found in: " + JSON.stringify(term));
  }
}

// show.ts

import { Term } from "./Type";

// Implement the term show function
export function show(term: Term): string {
  switch (term.$) {
    case "Var":
      return term.k;
    case "Idx":
      return "^" + term.i + "<" + show(term.t) + ">";
    case "Sub":
      return "unreachable";
    case "Frz":
      return "∅" + show(term.x);
    case "Set":
      return "*";
    case "Met":
      return "?" + term.x + ":" + show(term.T) + ";" + show(term.f);
    case "Let":
      return "!" + term.x + ":" + show(term.t) + "=" + show(term.v) + ";" + show(term.f);
    case "Fix":
      return "μ" + term.x + "." + show(term.f);
    case "Ann":
      return "<" + show(term.x) + ":" + show(term.t) + ">";
    case "Chk":
      return "(" + show(term.x) + "::" + show(term.t) + ")";
    case "Set":
      return "%";
    case "Emp":
      return "⊥";
    case "Efq":
      return "λ{}";
    case "Uni":
      return "⊤";
    case "One":
      return "()";
    case "Use":
      return "λ{():" + show(term.f) + "}";
    case "Bit":
      return "𝔹";
    case "Bt0":
      return "#0";
    case "Bt1":
      return "#1";
    case "Bif":
      return "λ{#0:" + show(term.f) + ";#1:" + show(term.t) + "}";
    case "Sig":
      return "Σ" + show(term.a) + "." + show(term.b);
    case "Tup":
      return "(" + show(term.a) + "," + show(term.b) + ")";
    case "Get":
      return "λ{(,):" + show(term.f) + "}";
    case "All":
      return "Π" + show(term.a) + "." + show(term.b);
    case "Lam":
      return "λ" + term.k + "." + show(term.f);
    case "App":
      return "(" + show(term.f) + " " + show(term.x) + ")";
    case "Fin":
      return "{" + show(term.l) + "}";
    case "Nat":
      return "ℕ";
    case "Zer":
      return "0";
    case "Suc":
      return "↑" + show(term.n);
    case "Add":
      return show(term.a) + "+" + show(term.b);
    case "Swi":
      return "λ{0:" + show(term.z) + ";+:" + show(term.s) + "}";
    case "Lst":
      return show(term.t) + "[]";
    case "Vec":
      return show(term.t) + "[" + show(term.l) + "]";
    case "Nil":
      return "[]";
    case "Con":
      return show(term.h) + "<>" + show(term.t);
    case "Mat":
      return "λ{[]:" + show(term.n) + ";<>:" + show(term.c) + "}";
    case "Eql":
      return show(term.a) + "==" + show(term.b) + ":" + show(term.t);
    case "Rfl":
      return "{=}";
    case "Tst":
      return "{:=}";
    case "Rwt":
      return "λ{{=}: " + show(term.f) + "}";
  }
}

// Export the old name for backward compatibility
export const showTerm = show;

// toHVM.ts

import { Term } from "./Type";

export function toHVM(term: Term): string {
  function encodeSeed(seed: string): string {
    if (!seed || seed.length === 0) return "#E";
    
    if (seed.startsWith("#")) {
      seed = seed.substring(1);
    }
    
    let result = "#E";
    for (let i = seed.length - 1; i >= 0; i--) {
      if (seed[i] === "1") {
        result = `#I{${result}}`;
      } else if (seed[i] === "0") {
        result = `#O{${result}}`;
      } else {
        throw new Error(`Invalid seed character: ${seed[i]}`);
      }
    }
    
    return result;
  }

  function go(t: Term, bound = new Set<string>()): string {
    switch (t.$) {
      case "Var":
        return t.k;
      case "Idx":
        return `#IDX{${t.i} ${go(t.t, bound)}}`;
      case "Sub":
        return `#SUB{${go(t.t, bound)}}`;
      case "Frz":
        return `#FRZ{${go(t.x, bound)}}`;
      case "Ann":
        return `#ANN{${go(t.x, bound)} ${go(t.t, bound)}}`;
      case "Chk":
        return `#CHK{${go(t.x, bound)} ${go(t.t, bound)}}`;
      case "Met": {
        const typeStr = go(t.T, bound);
        const encodedSeed = encodeSeed(t.S);
        const contextStr = t.C.map(c => go(c, bound)).join(" ");
        const compiledContext = `[${contextStr}]`;
        const newBound = new Set(bound);
        newBound.add(t.x);
        newBound.add(t.x + "$");
        const lambdaPrefix = `λ&${t.x} λ&${t.x + "$"}`;
        return `#MET{${typeStr} ${encodedSeed} ${compiledContext} ${lambdaPrefix} ${go(t.f, newBound)}}`;
      }
      case "Set":
        return `#SET`;
      case "Emp":
        return `#EMP`;
      case "Efq":
        return `#EFQ`;
      case "Uni":
        return `#UNI`;
      case "One":
        return `#ONE`;
      case "Use":
        return `#USE{${go(t.f, bound)}}`;
      case "Bit":
        return `#BIT`;
      case "Bt0":
        return `#BT0`;
      case "Bt1":
        return `#BT1`;
      case "Bif":
        return `#BIF{${go(t.f, bound)} ${go(t.t, bound)}}`;
      case "Sig":
        return `#SIG{${go(t.a, bound)} ${go(t.b, bound)}}`;
      case "Tup":
        return `#TUP{${go(t.a, bound)} ${go(t.b, bound)}}`;
      case "Get":
        return `#GET{${go(t.f, bound)}}`;
      case "All":
        return `#ALL{${go(t.a, bound)} ${go(t.b, bound)}}`;
      case "Lam": {
        const newBound = new Set(bound);
        newBound.add(t.k);
        const lambdaPrefix = `λ&${t.k}`;
        return `#LAM{${lambdaPrefix}. ${go(t.f, newBound)}}`;
      }
      case "App":
        return `#APP{${go(t.f, bound)} ${go(t.x, bound)}}`;
      case "Fin":
        return `#FIN{${go(t.l, bound)}}`;
      case "Nat":
        return `#NAT`;
      case "Zer":
        return `#ZER`;
      case "Suc":
        return `#SUC{${go(t.n, bound)}}`;
      case "Add":
        return `#ADD{${go(t.a, bound)} ${go(t.b, bound)}}`;
      case "Swi":
        return `#SWI{${go(t.z, bound)} ${go(t.s, bound)}}`;
      case "Lst":
        return `#LST{${go(t.t, bound)}}`;
      case "Vec":
        return `#VEC{${go(t.t, bound)} ${go(t.l, bound)}}`;
      case "Nil":
        return `#NIL`;
      case "Con":
        return `#CON{${go(t.h, bound)} ${go(t.t, bound)}}`;
      case "Mat":
        return `#MAT{${go(t.n, bound)} ${go(t.c, bound)}}`;
      case "Eql":
        return `#EQL{${go(t.a, bound)} ${go(t.b, bound)} ${go(t.t, bound)}}`;
      case "Rfl":
        return `#RFL`;
      case "Tst":
        return `#TST`;
      case "Rwt":
        return `#RWT{${go(t.f, bound)}}`;
      case "Let": {
        const typeStr = go(t.t, bound);
        const valStr = go(t.v, bound);
        const newBound = new Set(bound);
        newBound.add(t.x);
        const lambdaPrefix = `λ&${t.x}`;
        return `#LET{${typeStr} ${valStr} ${lambdaPrefix} ${go(t.f, newBound)}}`;
      }
      case "Fix": {
        const newBound = new Set(bound);
        newBound.add(t.x);
        const lambdaPrefix = `λ&${t.x}`;
        return `#FIX{${lambdaPrefix} ${go(t.f, newBound)}}`;
      }
    }
  }

  return go(term);
}

export const termToHVM = toHVM;

// Type.ts

export type Name = string;
export type LamB = (term: Term) => Term;

// Term ::=
//   | VAR: x
//   | IDX: x
//   | SUB: x
//   | SET: *
//   | ANN: <x:T>
//   | CHK: x::T
//   | MET: ?x:T#S{C};f
//   | LET: !x:T=v;f
//   | FIX: μx.f
//   | SET: %
//   | EMP: ⊥
//   | EFQ: λ{}
//   | UNI: ⊤
//   | ONE: ()
//   | USE: λ{():f}
//   | BIT: 𝔹
//   | BT0: #0
//   | BT1: #1
//   | BIF: λ{#0:f;#1:t}
//   | SIG: ΣA.B
//   | TUP: a,b
//   | GET: λ{(,):f}
//   | ALL: ΠA.B
//   | LAM: λx.f
//   | APP: (f x)
//   | NAT: ℕ
//   | ZER: 0
//   | SUC: (+n)
//   | SWI: λ{0:z;+:s}
//   | LST: T[]
//   | NIL: []
//   | CON: h<>t
//   | MAT: λ{[]:n;<>:c}

export type Term =
  | { $: "Var", k: Name }
  | { $: "Idx", i: number, t: Term }
  | { $: "Sub", t: Term }
  | { $: "Frz", x: Term }
  | { $: "Set" }
  | { $: "Ann", x: Term, t: Term }
  | { $: "Chk", x: Term, t: Term }
  | { $: "Met", x: Name, T: Term, S: string, C: Term[], f: Term }
  | { $: "Let", x: Name, t: Term, v: Term, f: Term }
  | { $: "Fix", x: Name, f: Term }
  | { $: "Set" }
  | { $: "Emp" }
  | { $: "Efq" }
  | { $: "Uni" }
  | { $: "One" }
  | { $: "Use", f: Term }
  | { $: "Bit" }
  | { $: "Bt0" }
  | { $: "Bt1" }
  | { $: "Bif", f: Term, t: Term }
  | { $: "Sig", a: Term, b: Term }
  | { $: "Tup", a: Term, b: Term }
  | { $: "Get", f: Term }
  | { $: "All", a: Term, b: Term }
  | { $: "Lam", k: Name, f: Term }
  | { $: "App", f: Term, x: Term }
  | { $: "Fin", l: Term }
  | { $: "Nat" }
  | { $: "Zer" }
  | { $: "Suc", n: Term }
  | { $: "Add", a: Term, b: Term }
  | { $: "Swi", z: Term, s: Term }
  | { $: "Lst", t: Term }
  | { $: "Vec", t: Term, l: Term }
  | { $: "Nil" }
  | { $: "Con", h: Term, t: Term }
  | { $: "Mat", n: Term, c: Term }
  | { $: "Eql", a: Term, b: Term, t: Term }
  | { $: "Rfl" }
  | { $: "Tst" }
  | { $: "Rwt", f: Term }

-- Old Kind7 files (for inspiration):

module Type where

import Control.Monad
import Data.Function (fix)
import qualified Data.IntMap.Strict as IM

data Bin
  = O Bin
  | I Bin
  | E

type Name = String

type Body = Term -> Term

type Lab = Integer

data Term
  = Var Name          -- x
  | Idx Int Term      -- x
  | Sub Term          -- x
  | Era               -- -
  | Sup Lab Term Term -- &L{a b}
  | Fix Term          -- μx.f
  | Ann Term Term     -- <x:T>
  | Chk Term Term     -- x::T
  | Let Term Term     -- !v;f
  | Set               -- %
  | Emp               -- ⊥
  | Efq               -- λ{}
  | Uni               -- ⊤
  | One               -- ()
  | Use Term          -- λ{():f}
  | Bit               -- 𝔹
  | Bt0               -- #0
  | Bt1               -- #1
  | Bif Term Term     -- λ{#0:f;#1:t}
  | Sig Term Term     -- ΣA.B
  | Tup Term Term     -- a,b
  | Get Term          -- λ{(,):f}
  | All Term Term     -- ΠA.B
  | Lam Name Body     -- λx.f
  | App Term Term     -- (f x)
  | Nat               -- ℕ
  | Zer               -- 0
  | Suc Term          -- (+n)
  | Swi Term Term     -- λ{0:z;+:s}
  | Lst Term          -- T[]
  | Nil               -- []
  | Con Term Term     -- h<>t
  | Mat Term Term     -- λ{[]:n;<>:c}

instance Show Term where
  show :: Term -> String
  show (Var k)     = k
  show (Idx i t)   = "^" ++ show i ++ "<" ++ show t ++ ">"
  show (Sub _)     = error "unreachable"
  show Era         = "*"
  show (Sup k a b) = "&" ++ show k ++ "{" ++ show a ++ " " ++ show b ++ "}"
  show (Fix t)     = "μ" ++ show t
  show (Let v f)   = "!" ++ show v ++ ";" ++ show f
  show (Ann x t)   = "<" ++ show x ++ ":" ++ show t ++ ">"
  show (Chk x t)   = "(" ++ show x ++ "::" ++ show t ++ ")"
  show Set         = "%"
  show Emp         = "⊥"
  show Efq         = "λ{}"
  show Uni         = "⊤"
  show One         = "()"
  show (Use f)     = "λ{():" ++ show f ++ "}"
  show Bit         = "𝔹"
  show Bt0         = "#0"
  show Bt1         = "#1"
  show (Bif f t)   = "λ{#0:" ++ show f ++ ";#1:" ++ show t ++ "}"
  show (Sig a b)   = "Σ" ++ show a ++ "." ++ show b
  show (Tup a b)   = "(" ++ show a ++ "," ++ show b ++ ")"
  show (Get f)     = "λ{(,):" ++ show f ++ "}"
  show (All a b)   = "Π" ++ show a ++ "." ++ show b
  show (Lam k f)   = "λ" ++ k ++ "." ++ show (f (Var k))
  show (App f x)   = "(" ++ show f ++ " " ++ show x ++ ")"
  show Nat         = "ℕ"
  show Zer         = "0"
  show (Suc n)     = "(↑" ++ show n ++ ")"
  show (Swi z s)   = "λ{0:" ++ show z ++ ";+:" ++ show s ++ "}"
  show (Lst t)     = show t ++ "[]"
  show Nil         = "[]"
  show (Con h t)   = "(" ++ show h ++ "<>" ++ show t ++ ")"
  show (Mat n c)   = "λ{[]:" ++ show n ++ ";<>:" ++ show c ++ "}"

module WHNF where

import Type

whnf :: Term -> Term
whnf term = case term of
  Let v f -> whnfLet (whnf v) f
  Fix f   -> whnfFix (whnf f)
  Ann x _ -> whnf x
  Chk x _ -> whnf x
  App f x -> whnfApp (whnf f) x
  _       -> term

whnfLet :: Term -> Term -> Term
whnfLet v f = whnf (App f (whnf v))

whnfFix :: Term -> Term
whnfFix (Lam k f) = whnf (f (Fix (Lam k f)))
whnfFix t         = Fix t

whnfApp :: Term -> Term -> Term
whnfApp (Sup k a b) x =
  Sup k (App a x) (App b x)
whnfApp (Lam _ f) x =
  whnf (f (whnf x))
whnfApp (Get f) x = case whnf x of
  Sup k a b -> Sup k (App (Get f) a) (App (Get f) b)
  Tup a b   -> whnf (App (App f (whnf a)) (whnf b))
  _         -> App (Get f) x
whnfApp (Swi z s) x = case whnf x of
  Sup k a b -> Sup k (App (Swi z s) a) (App (Swi z s) b)
  Zer       -> whnf z
  Suc n     -> whnf (App s (whnf n))
  _         -> App (Swi z s) x
whnfApp (Use f) x = case whnf x of
  Sup k a b -> Sup k (App (Use f) a) (App (Use f) b)
  One       -> whnf f
  _         -> App (Use f) x
whnfApp (Bif f t) x = case whnf x of
  Sup k a b -> Sup k (App (Bif f t) a) (App (Bif f t) b)
  Bt0       -> whnf f
  Bt1       -> whnf t
  _         -> App (Bif f t) x
whnfApp (Mat n c) x = case whnf x of
  Sup k a b -> Sup k (App (Mat n c) a) (App (Mat n c) b)
  Nil       -> whnf n
  Con h t   -> whnf (App (App c (whnf h)) (whnf t))
  _         -> App (Mat n c) x
whnfApp f x = App f x

module Equal where

import Prelude hiding (and)
import Type
import WHNF

equal :: Int -> Term -> Term -> Term
equal lv a b = case (whnf a, whnf b) of
  (Var ak       , Var bk)       -> if ak == bk then Uni else Emp
  (Idx ai _     , Idx bi _)     -> if ai == bi then Uni else Emp
  (Sup ak ax ay , Sup bk bx by) -> equal_sups lv ak ax ay bk bx by
  (Sup ak ax ay , b)            -> Sup ak (equal lv ax b) (equal lv ay b)
  (a            , Sup bk bx by) -> Sup bk (equal lv a bx) (equal lv a by)
  (Let av af    , Let bv bf)    -> both (equal lv av bv) (equal lv af bf)
  (Ann ax _     , Ann bx _)     -> equal lv ax bx
  (Chk ax _     , Chk bx _)     -> equal lv ax bx
  (Set          , Set)          -> Uni
  (Emp          , Emp)          -> Uni
  (Efq          , Efq)          -> Uni
  (Uni          , Uni)          -> Uni
  (One          , One)          -> Uni
  (Use af       , Use bf)       -> equal lv af bf
  (Bit          , Bit)          -> Uni
  (Bt0          , Bt0)          -> Uni
  (Bt1          , Bt1)          -> Uni
  (Bif af at    , Bif bf bt)    -> both (equal lv af bf) (equal lv at bt)
  (Sig aX aY    , Sig bX bY)    -> both (equal lv aX bX) (equal lv aY bY)
  (Tup ax ay    , Tup bx by)    -> both (equal lv ax bx) (equal lv ay by)
  (Get af       , Get bf)       -> equal lv af bf
  (All aA aB    , All bA bB)    -> both (equal lv aA bA) (equal lv aB bB)
  (Lam ak af    , Lam bk bf)    -> equal (lv+1) (af (Idx lv (Var ak))) (bf (Idx lv (Var bk)))
  (App af ax    , App bf bx)    -> both (equal lv af bf) (equal lv ax bx)
  (Nat          , Nat)          -> Uni
  (Zer          , Zer)          -> Uni
  (Suc an       , Suc bn)       -> equal lv an bn
  (Swi az as    , Swi bz bs)    -> both (equal lv az bz) (equal lv as bs)
  (Lst aT       , Lst bT)       -> equal lv aT bT
  (Nil          , Nil)          -> Uni
  (Con ah at    , Con bh bt)    -> both (equal lv ah bh) (equal lv at bt)
  (Mat an ac    , Mat bn bc)    -> both (equal lv an bn) (equal lv ac bc)
  (_            , _)            -> Emp

equal_sups :: Int -> Lab -> Term -> Term -> Lab -> Term -> Term -> Term
equal_sups lv ak ax ay bk bx by
  | ak == bk  = Sup ak (equal lv ax bx) (equal lv ay by)
  | otherwise = Sup ak s0 s1  where
    s0 = Sup bk (equal lv ax bx) (equal lv ax by)
    s1 = Sup bk (equal lv ay bx) (equal lv ay by)

both :: Term -> Term -> Term
both a b = case (whnf a , whnf b) of
  (Sup ak ax ay , Sup bk bx by) -> both_sups ak ax ay bk bx by
  (Sup ak ax bx , b)            -> Sup ak (both ax b) (both bx b)
  (a , Sup bk bx by)            -> Sup bk (both a bx) (both a by)
  (Uni , Uni)                   -> Uni
  (Uni , Emp)                   -> Emp
  (Emp , Uni)                   -> Emp
  (Emp , Emp)                   -> Emp
  _                             -> Emp

both_sups :: Lab -> Term -> Term -> Lab -> Term -> Term -> Term
both_sups ak ax ay bk bx by
  | ak == bk  = Sup ak (both ax bx) (both ay by)
  | otherwise = Sup ak s0 s1 where
    s0 = (Sup bk (both ax bx) (both ax by))
    s1 = (Sup bk (both ay bx) (both ay by))


module Normal where

import Type
import WHNF

normal :: Int -> Term -> Term
normal lv term = case whnf term of
  Var k     -> Var k
  Idx i t   -> Idx i (normal lv t)
  Sub t     -> t
  Era       -> Era
  Sup k a b -> Sup k (normal lv a) (normal lv b)
  Fix t     -> Fix (normal lv t)
  Ann x t   -> Ann (normal lv x) (normal lv t)
  Chk x t   -> Chk (normal lv x) (normal lv t)
  Let v f   -> Let (normal lv v) (normal lv f)
  Set       -> Set
  Emp       -> Emp
  Efq       -> Efq
  Uni       -> Uni
  One       -> One
  Use f     -> Use (normal lv f)
  Bit       -> Bit
  Bt0       -> Bt0
  Bt1       -> Bt1
  Bif f t   -> Bif (normal lv f) (normal lv t)
  Sig a b   -> Sig (normal lv a) (normal lv b)
  Tup a b   -> Tup (normal lv a) (normal lv b)
  Get f     -> Get (normal lv f)
  All a b   -> All (normal lv a) (normal lv b)
  Lam k f   -> Lam k (\x                         -> normal lv (f (Sub x)))
  App f x   -> App (normal lv f) (normal lv x)
  Nat       -> Nat
  Zer       -> Zer
  Suc n     -> Suc (normal lv n)
  Swi z s   -> Swi (normal lv z) (normal lv s)
  Lst t     -> Lst (normal lv t)
  Nil       -> Nil
  Con h t   -> Con (normal lv h) (normal lv t)
  Mat n c   -> Mat (normal lv n) (normal lv c)

-- TASK: create a Parser for Kind7.
-- - don't be inventive, just use a simple approach that is guaranteed to work
-- - keep it simple and idiomatic
-- - include nice error messages

-- On the 'parseApp parser:
-- - support (f x y z) as an alias to (((f x) y) z)
-- - do so by parsing '(', then terms until you hit a ')', then foldl to build the App

-- Note on operators:
-- - syntaxes like 'a,b', 'a<>b', 'a->b', 'a:b', etc., MUST be treated as operators
-- - there is no precedence, and operators always fold right: a,b,c,d → a,(b,(c,d))
-- - implemented his using as imple logic:
--   - the term parser is split in two: parseTermIni and parseTermEnd
--   - the parseTermIni handles all core syntaxes (i.e., non-operators)
--   - the parseTermEnd receives the Term parsed by parseTermIni, and attempts to parse an operator
-- - this allows fast parsing with less backtracking and better error messages

-- Note on error messages:
-- - it should be inspired (but not identical) on this old error implementation:
-- import Highlight (highlightError, highlight)
-- showParseError :: String -> String -> P.ParseError -> IO ()
-- showParseError filename input err = do
--   let pos = errorPos err
--   let lin = sourceLine pos
--   let col = sourceColumn pos
--   let msg = extractExpectedTokens err
--   putStrLn $ setSGRCode [SetConsoleIntensity BoldIntensity] ++ "\nPARSE_ERROR" ++ setSGRCode [Reset]
--   putStrLn $ "- expected: " ++ msg
--   putStrLn $ "- detected:"
--   putStrLn $ highlightError (lin, col) (lin, col + 1) input
--   putStrLn $ setSGRCode [SetUnderlining SingleUnderline] ++ filename ++
--              setSGRCode [Reset] ++ " " ++ show lin ++ ":" ++ show col
-- simplify and adapt it to your own implementation
-- use the Highlight import. IT ALREADY EXISTS, DO NOT RE-CREATE IT.

-- About lambdas:
-- - do NOT handle shadowing or substitution in any way
-- - just parse the input strings into the terms
-- - this is handled elsewhre - separation of concerns

-- remember:
-- - keep this file as simple, elegant and idiomatic.
-- - do not write anything beyond what has been explicitly asked.

module Parse where

import Data.Char (isAsciiLower, isAsciiUpper, isDigit)
import Data.Void
import Highlight (highlightError)
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Data.List.NonEmpty as NE
import qualified Text.Megaparsec.Char.Lexer as L

import Bind
import Type

type Parser = Parsec Void String

skip :: Parser ()
skip = L.space space1 (L.skipLineComment "//") (L.skipBlockComment "/*" "*/")

lexeme :: Parser a -> Parser a
lexeme = L.lexeme skip

symbol :: String -> Parser String
symbol = L.symbol skip

parens :: Parser a -> Parser a
parens = between (symbol "(") (symbol ")")

angles :: Parser a -> Parser a
angles = between (symbol "<") (symbol ">")

braces :: Parser a -> Parser a
braces = between (symbol "{") (symbol "}")

brackets :: Parser a -> Parser a
brackets = between (symbol "[") (symbol "]")

isNameInit :: Char -> Bool
isNameInit c = isAsciiLower c || isAsciiUpper c || c == '_'

isNameChar :: Char -> Bool
isNameChar c = isAsciiLower c || isAsciiUpper c || isDigit c || c == '_'

name :: Parser String
name = lexeme $ do
  head <- satisfy isNameInit <?> "letter or underscore"
  tail <- many (satisfy isNameChar <?> "letter, digit, or underscore")
  return (head : tail)

formatError :: String -> ParseErrorBundle String Void -> String
formatError input bundle =
  let obj = NE.head $ fst $ attachSourcePos errorOffset (bundleErrors bundle) (bundlePosState bundle)
      err = fst obj
      pos = snd obj
      lin = unPos (sourceLine pos)
      col = unPos (sourceColumn pos)
      msg = parseErrorTextPretty err
      highlighted = highlightError (lin, col) (lin, col + 1) input
  in  "\nPARSE_ERROR\n" ++ msg ++ "\n" ++
      "At line " ++ show lin ++ ", column " ++ show col ++ ":\n" ++
      highlighted

parseTerm :: Parser Term
parseTerm = do
  term <- parseTermIni
  parseTermEnd term

parseTermIni :: Parser Term
parseTermIni = choice
  [ parseVar
  , parseEra
  , parseSup
  , parseFix
  , parseSet
  , parseEmp
  , parseUni
  , parseOne
  , parseBit
  , parseBt0
  , parseBt1
  , parseNat
  , parseZer
  , parseNil
  , parseApp
  , parseAll
  , parseSig
  , parseAnn
  , parseLet
  , parseSuc
  , try parseUse
  , try parseBif
  , try parseEfq
  , try parseGet
  , try parseSwi
  , try parseMat
  , try parseLam
  ]

parseTermEnd :: Term -> Parser Term
parseTermEnd term = choice
  [ parseTup term
  , parseCon term
  , parseFun term
  , parseChk term
  , parseLst term
  , return term
  ]

parseVar :: Parser Term
parseVar = do
  k <- name
  return $ Var k

parseEra :: Parser Term
parseEra = do
  _ <- symbol "*"
  return Era

parseSup :: Parser Term
parseSup = braces $ do
  _ <- symbol "&"
  k <- lexeme L.decimal
  a <- parseTerm
  b <- parseTerm
  return $ Sup k a b

parseFix :: Parser Term
parseFix = do
  _ <- symbol "μ"
  t <- parseTerm
  return $ Fix t

parseSet :: Parser Term
parseSet = do
  _ <- symbol "%"
  return Set

parseEmp :: Parser Term
parseEmp = do
  _ <- symbol "⊥"
  return Emp

parseEfq :: Parser Term
parseEfq = do
  _ <- symbol "λ{}"
  return Efq

parseUni :: Parser Term
parseUni = do
  _ <- symbol "⊤"
  return Uni

parseOne :: Parser Term
parseOne = do
  _ <- symbol "()"
  return One

parseBit :: Parser Term
parseBit = do
  _ <- symbol "𝔹"
  return Bit

parseBt0 :: Parser Term
parseBt0 = do
  _ <- symbol "#0"
  return Bt0

parseBt1 :: Parser Term
parseBt1 = do
  _ <- symbol "#1"
  return Bt1

parseNat :: Parser Term
parseNat = do
  _ <- symbol "ℕ"
  return Nat

parseZer :: Parser Term
parseZer = do
  _ <- symbol "0"
  return Zer

parseNil :: Parser Term
parseNil = do
  _ <- symbol "[]"
  return Nil

parseSuc :: Parser Term
parseSuc = do
  _ <- symbol "+"
  n <- parseTerm
  return $ Suc n

parseApp :: Parser Term
parseApp = parens $ do
  f  <- parseTerm
  xs <- many parseTerm
  return $ foldl App f xs

parseLam :: Parser Term
parseLam = do
  _ <- symbol "λ"
  k <- name
  _ <- symbol "."
  body <- parseTerm
  return $ Lam k (\v -> body)

parseAll :: Parser Term
parseAll = do
  _ <- symbol "Π" <|> symbol "Pi"
  a <- parseTerm
  _ <- symbol "."
  b <- parseTerm
  return $ All a b

parseSig :: Parser Term
parseSig = do
  _ <- symbol "Σ" <|> symbol "Sigma"
  a <- parseTerm
  _ <- symbol "."
  b <- parseTerm
  return $ Sig a b

parseSwi :: Parser Term
parseSwi = do
  _ <- symbol "λ"
  _ <- symbol "{"
  _ <- symbol "0:"
  z <- parseTerm
  _ <- symbol ";"
  _ <- symbol "+"
  _ <- symbol ":"
  s <- parseTerm
  _ <- symbol "}"
  return $ Swi z s

parseUse :: Parser Term
parseUse = do
  _ <- symbol "λ"
  _ <- symbol "{"
  _ <- symbol "()"
  _ <- symbol ":"
  f <- parseTerm
  _ <- symbol "}"
  return $ Use f

parseBif :: Parser Term
parseBif = do
  _ <- symbol "λ"
  _ <- symbol "{"
  _ <- symbol "#0:"
  f <- parseTerm
  _ <- symbol ";"
  _ <- symbol "#1:"
  t <- parseTerm
  _ <- symbol "}"
  return $ Bif f t

parseGet :: Parser Term
parseGet = do
  _ <- symbol "λ"
  _ <- symbol "{"
  _ <- symbol "(,)"
  _ <- symbol ":"
  f <- parseTerm
  _ <- symbol "}"
  return $ Get f

parseMat :: Parser Term
parseMat = do
  _ <- symbol "λ"
  _ <- symbol "{"
  _ <- symbol "[]"
  _ <- symbol ":"
  n <- parseTerm
  _ <- symbol ";"
  _ <- symbol "<>"
  _ <- symbol ":"
  c <- parseTerm
  _ <- symbol "}"
  return $ Mat n c

parseAnn :: Parser Term
parseAnn = angles $ do
  x <- parseTerm
  _ <- symbol ":"
  t <- parseTerm
  return $ Ann x t

parseLet :: Parser Term
parseLet = do
  _ <- symbol "!"
  v <- parseTerm
  _ <- symbol ";"
  f <- parseTerm
  return $ Let v f

parseTup :: Term -> Parser Term
parseTup term = do
  _ <- symbol ","
  t <- parseTerm
  return $ Tup term t

parseCon :: Term -> Parser Term
parseCon term = do
  _ <- symbol "<>"
  t <- parseTerm
  return $ Con term t

parseFun :: Term -> Parser Term
parseFun term = do
  _ <- symbol "->"
  t <- parseTerm
  return $ All term t

parseChk :: Term -> Parser Term
parseChk term = do
  _ <- symbol "::"
  t <- parseTerm
  return $ Chk term t

parseLst :: Term -> Parser Term
parseLst term = do
  _ <- symbol "[]"
  return $ Lst term

doParseTerm :: String -> String -> Either String Term
doParseTerm file code = case parse parseTerm file code of
  Left err  -> Left $ formatError code err
  Right res -> Right (bind res)

doReadTerm :: String -> Term
doReadTerm input = case doParseTerm "no-file" input of
  Left err  -> error err
  Right res -> res

-- Kolmo's HVM-based type-checker (we must follow it as closely as possible):

import Prelude.hvm
import Kolmo.Type.hvm
import Kolmo.rewrite.hvm

// Type-Checking
// -------------
// TODO: include proper contexts

// infer : U32 → Term → Result String Term
!@infer(!&dep !term) =
  ~ term {
    #VAR{k}:
      #Fail{#CantInfer{#VAR{k}}}
    #IDX{i v}:
      @infer(dep v)
    #SUB{x}:
      @infer(dep x)
    #FRZ{x}:
      #Done{#UNI}
    #MET{T S C f}:
      *
    #LET{T v f}: !&{v0 v1}=v !&{T0 T1}=T ~ @check(dep v0 T0) {
      #Done{_}: @infer((+ dep 1) (f #ANN{v1 T1}))
      #Fail{e}: #Fail{e}
    }
    #FIX{f}: 
      #Fail{#CantInfer{#FIX{f}}}
    #ANN{v T}:
      #Done{T}
    #SET:
      #Done{#SET}
    #EMP:
      #Done{#SET}
    #EFQ:
      #Done{#ALL{#EMP #LAM{λx.#EMP}}}
    #UNI:
      #Done{#SET}
    #ONE:
      #Done{#UNI}
    #USE{f}:
      #Fail{#CantInfer{#USE{f}}}
    #BIT:
      #Done{#SET}
    #BT0:
      #Done{#BIT}
    #BT1:
      #Done{#BIT}
    #BIF{o i}:
      #Fail{#CantInfer{#BIF{o i}}}
    #SIG{a b}: !&{a0 a1}=a ~ @check(dep a0 #SET) {
      #Done{_}: ~ @check(dep b #ALL{a1 #LAM{λx.#SET}}) {
        #Done{_}: #Done{#SET}
        #Fail{e}: #Fail{e}
      }
      #Fail{e}: #Fail{e}
    }
    #TUP{a b}: ~ @infer(dep a) {
      #Done{X}: ~ @infer(dep b) {
        #Done{Y}: #Done{#SIG{X #LAM{λx.Y}}}
        #Fail{e}: #Fail{e}
      }
      #Fail{e}: #Fail{e}
    }
    #GET{f}:
      #Fail{#CantInfer{#GET{f}}}
    #ALL{A B}: ~ @check(dep A #SET) {
      #Done{_}: ~ @check(dep B #ALL{#SET #LAM{λx.#SET}}) {
        #Done{_}: #Done{#SET}
        #Fail{e}: #Fail{e}
      }
      #Fail{e}: #Fail{e}
    }
    #LAM{f}:
      #Fail{#CantInfer{#LAM{f}}}
    #APP{f x}: ~ @infer(dep f) {
      #Done{fT}: ~ @whnf(fT) {
        #ALL{fA fB}: !&{x0 x1}=x ~ @check(dep x0 fA) {
          #Done{_}: #Done{#APP{fB x1}}
          #Fail{e}: #Fail{e}
        }
        _: #Fail{#NonFunApp}
      }
      #Fail{e}: #Fail{e}
    }
    #NAT:
      #Done{#SET}
    #FIN{L}:
      #Done{#SET}
    #ZER:
      #Done{#NAT}
    #SUC{n}: ~ @check(dep n #NAT) {
      #Done{_}: #Done{#NAT}
      #Fail{e}: #Fail{e}
    }
    #ADD{a b}: ~ @check(dep a #NAT) {
      #Done{_}: ~ @check(dep b #NAT) {
        #Done{_}: #Done{#NAT}
        #Fail{e}: #Fail{e}
      }
      #Fail{e}: #Fail{e}
    }
    #SWI{z s}:
      #Fail{#CantInfer{#SWI{z s}}}
    #LST{T}: ~ @check(dep T #SET) {
      #Done{_}: #Done{#SET}
      #Fail{e}: #Fail{e}
    }
    #VEC{T L}: ~ @check(dep T #SET) {
      #Done{_}: ~ @check(dep L #NAT) {
        #Done{_}: #Done{#SET}
        #Fail{e}: #Fail{e}
      }
      #Fail{e}: #Fail{e}
    }
    #NIL: 
      #Fail{#CantInfer{#NIL}}
    #CON{h t}:
      #Fail{#CantInfer{#CON{h t}}}
    #MAT{n c}:
      #Fail{#CantInfer{#MAT{n c}}}
    #EQL{a b T}:
      #Done{#SET}
    #RFL:
      #Fail{#CantInfer{#RFL}}
    #TST:
      #Fail{#CantInfer{#TST}}
    #RWT{f}:
      #Fail{#CantInfer{#RWT{f}}}
  }

// check : U32 → Term → Result String ()
!@check(!&dep !term goal) =
  @check_go(dep term @force(goal))

!@check_go(!&dep !term !goal) =
  ~ term !goal {
    #ONE: ~ goal {
      #UNI: #Done{1}
      goal: #Fail{#TypeMismatch{#ONE #UNI goal}}
    }
    #BT0: ~ goal {
      #BIT: #Done{1}
      goal: #Fail{#TypeMismatch{#BT0 #BIT goal}}
    }
    #BT1: ~ goal {
      #BIT: #Done{1}
      goal: #Fail{#TypeMismatch{#BT1 #BIT goal}}
    }
    #ZER: ~ goal {
      #NAT: #Done{1}
      goal: #Fail{#TypeMismatch{#ZER #NAT goal}}
    }
    #SUC{n}: ~ goal !n {
      #NAT: ~ @check(dep n #NAT) {
        #Done{_}: #Done{1}
        #Fail{e}: #Fail{e}
      }
      goal: #Fail{#TypeMismatch{#SUC{n} #NAT goal}}
    }
    #NIL: ~ goal {
      #LST{T}: #Done{1}
      #VEC{T &L}: ~ @whnf(L) {
        #ZER: #Done{1}
        L: #Fail{#TypeMismatch{#NIL #VEC{T L} #VEC{#VAR{0} #ZER}}}
      }
      goal: #Fail{#TypeMismatch{#NIL #LST{#VAR{0}} goal}}
    }
    #CON{h t}: ~ goal !h !t {
      #LST{&T}: ~ @check(dep h T) !T {
        #Done{_}: ~ @check(dep t #LST{T}) {
          #Done{_}: #Done{1}
          #Fail{e}: #Fail{e}
        }
        #Fail{e}: #Fail{e}
      }
      #VEC{&T L}: ~ @whnf(L) !h !t !&T {
        #SUC{L}: ~ @check(dep h T) !T {
          #Done{_}: ~ @check(dep t #VEC{T L}) {
            #Done{_}: #Done{1}
            #Fail{e}: #Fail{e}
          }
          #Fail{e}: #Fail{e}
        }
        L: #Fail{#TypeMismatch{#CON{h t} #VEC{T L} #VEC{#VAR{0} #SUC{#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#CON{h t} #LST{#VAR{0}} goal}}
    }
    #LAM{f}: ~ goal !f {
      #ALL{A B}:
        ! &{A0 A1}=A
        ~ @check((+ dep 1) (f #ANN{#VAR{dep} A0}) #APP{B #ANN{#VAR{dep} A1}}) {
          #Done{_}: #Done{1}
          #Fail{e}: #Fail{e}
        }
      goal: #Fail{#TypeMismatch{#LAM{f} #ALL{#VAR{0} #LAM{λx.#VAR{0}}} goal}}
    }
    #APP{f x}: ~ x !f !goal {
      // TODO: Not general, but works for linearized variables
      #ANN{x Tx}: @check(dep f #ALL{Tx #LAM{λv. @rewrite(dep x v goal)}})
      x: @verify(dep #APP{f x} goal)
    }
    // #APP{f x}: ~ f !&x !goal {
    //   #SWI{z s}: ~ @check(dep x #NAT) {
    //     #Done{_}: @check(dep #SWI{z s} #ALL{#NAT #LAM{λv. @rewrite(dep x v goal)}})
    //     #Fail{e}: #Fail{e}
    //   }
    //   // TODO: MAT case
    //   f: @verify(dep #APP{f x} goal)
    // }
    #EFQ: ~ goal {
      #ALL{A B}: ~ A !B {
        #EMP: #Done{1}
        A: #Fail{#TypeMismatch{#EFQ #ALL{A B} #ALL{#VAR{0} #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#EFQ #ALL{#VAR{0} #LAM{λx.#VAR{0}}} goal}}
    }
    #USE{f}: ~ goal !f {
      #ALL{A B}: ~ A !f !B {
        #UNI: ~ @check(dep f #APP{B #ONE}) {
          #Done{_}: #Done{1}
          #Fail{e}: #Fail{e}
        }
        A: #Fail{#TypeMismatch{#USE{f} #ALL{A B} #ALL{#UNI #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#USE{f} #ALL{#UNI #LAM{λx.#VAR{0}}} goal}}
    }
    #BIF{o i}: ~ goal !o !i {
      #ALL{A B}: ~ A !o !i !B {
        #BIT: !&{B0 B1}=B ~ @check(dep o #APP{B0 #BT0}) {
          #Done{_}: ~ @check(dep i #APP{B1 #BT1}) {
            #Done{_}: #Done{1}
            #Fail{e}: #Fail{e}
          }
          #Fail{e}: #Fail{e}
        }
        A: #Fail{#TypeMismatch{#BIF{o i} #ALL{A B} #ALL{#BIT #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#BIF{o i} #ALL{#BIT #LAM{λx.#VAR{0}}} goal}}
    }
    #SWI{z s}: ~ goal !z !s {
      #ALL{A B}: ~ A !z !s !B {
        #NAT: !&{B0 B1}=B ~ @check(dep z #APP{B0 #ZER}) {
          #Done{_}: ~ @check(dep s #ALL{#NAT #LAM{λn.#APP{B1 #SUC{n}}}}) {
            #Done{_}: #Done{1}
            #Fail{e}: #Fail{e}
          }
          #Fail{e}: #Fail{e}
        }
        A: #Fail{#TypeMismatch{#SWI{z s} #ALL{A B} #ALL{#NAT #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#SWI{z s} #ALL{#NAT #LAM{λx.#VAR{0}}} goal}}
    }
    #MAT{n c}: ~ goal !n !c {
      #ALL{A B}: ~ A !n !c !B {
        #LST{T}: !&{B0 B1}=B !&{T0 T1}=T ~ @check(dep n #APP{B0 #NIL}) {
          #Done{_}: ~ @check(dep c #ALL{T0 #LAM{λh.#ALL{#LST{T1} #LAM{λt.#APP{B1 #CON{h t}}}}}}) {
            #Done{_}: #Done{1}
            #Fail{e}: #Fail{e}
          }
          #Fail{e}: #Fail{e}
        }
        A: #Fail{#TypeMismatch{#MAT{n c} #ALL{A B} #ALL{#LST{#VAR{0}} #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#MAT{n c} #ALL{#LST{#VAR{0}} #LAM{λx.#VAR{0}}} goal}}
    }
    #GET{f}: ~ goal !f {
      #ALL{A B}: ~ A !f !B {
        #SIG{X Y}: ~ @check(dep f #ALL{X #LAM{λx.!&{x0 x1}=x #ALL{#APP{Y x0} #LAM{λy.#APP{B #TUP{x1 y}}}}}}) {
          #Done{_}: #Done{1}
          #Fail{e}: #Fail{e}
        }
        A: #Fail{#TypeMismatch{#GET{f} #ALL{A B} #ALL{#SIG{#VAR{0} #LAM{λx.#VAR{0}}} #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#GET{f} #ALL{#SIG{#VAR{0} #LAM{λx.#VAR{0}}} #LAM{λx.#VAR{0}}} goal}}
    }
    #TUP{a b}: ~ goal !a !b {
      #SIG{A B}: !&{a0 a1}=a ~ @check(dep a0 A) {
        #Done{_}: ~ @check(dep b #APP{B a1}) {
          #Done{_}: #Done{1}
          #Fail{e}: #Fail{e}
        }
        #Fail{e}: #Fail{e}
      }
      goal: #Fail{#TypeMismatch{#TUP{a b} #SIG{#VAR{0} #LAM{λx.#VAR{0}}} goal}}
    }
    #MET{T S C f}:
      *
    #LET{T v f}: !&{v0 v1}=v !&{T0 T1}=T ~ @check(dep v0 T0) {
      #Done{_}: ~ @check((+ dep 1) (f #ANN{v1 T1}) goal) {
        #Done{_}: #Done{1}
        #Fail{e}: #Fail{e}
      }
      #Fail{e}: #Fail{e}
    }
    #FIX{f}:
      ! &{goal T}=goal
      @check((+ dep 1) (f #ANN{#VAR{dep} T}) goal)
    #RFL: ~ goal {
      #EQL{&a &b &T}: ~ @check(dep a T) !&a !&b !&T {
        #Done{_}: ~ @check(dep b T) !&a !&b {
          #Done{_}: ~ @term_equal(dep a b) !&a !&b {
            0: #Fail{#TermMismatch{a b}}
            _: #Done{1}
          }
          #Fail{e}: #Fail{e}
        }
        #Fail{e}: #Fail{e}
      }
      goal: #Fail{#TypeMismatch{#RFL #EQL{#VAR{0} #VAR{0} #VAR{0}} goal}}
    }
    #TST: ~ goal {
      #EQL{&a &b &T}: ~ @check(dep a T) !&a !&b !&T {
        #Done{_}: ~ @check(dep b T) !&a !&b !&T {
          #Done{_}: ~ @comp_equal(dep @normal(dep T) a b) !&a !&b {
            0: #Fail{#TermMismatch{a b}}
            _: #Done{1}
          }
          #Fail{e}: #Fail{e}
        }
        #Fail{e}: #Fail{e}
      }
      goal: #Fail{#TypeMismatch{#TST #EQL{#VAR{0} #VAR{0} #VAR{0}} goal}}
    }
    #RWT{f}: ~ goal !f {
      #ALL{A B}: ~ A !f !B {
        #EQL{a b T}: ~ @check(dep f @rewrite(dep a b #APP{B #RFL})) {
          #Done{_}: #Done{1}
          #Fail{e}: #Fail{e}
        }
        A: #Fail{#TypeMismatch{#RWT{f} #ALL{A B} #ALL{#EQL{#VAR{0} #VAR{0} #VAR{0}} #LAM{λx.#VAR{0}}}}}
      }
      goal: #Fail{#TypeMismatch{#RWT{f} #ALL{#EQL{#VAR{0} #VAR{0} #VAR{0}} #LAM{λx.#VAR{0}}} goal}}
    }
    term: @verify(dep term goal)
  }

@verify(!&dep term goal) =
  ! &{term0 term1} = term
  ! &{goal0 goal1} = goal
  ~ @infer(dep term0) {
    #Done{type}:
      ! &{type0 type1} = type
      ~ @term_equal(dep type0 goal0) {
        0: #Fail{#TypeMismatch{term1 type1 goal1}}
        _: #Done{1}
      }
    #Fail{e}: #Fail{e}
  }

